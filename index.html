<!DOCTYPE html>
<html lang="en" data-theme="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Liquidation Heatmap</title>
    <link rel="stylesheet" href="output.css">
    <!-- Lightweight Charts library by TradingView (pinned to a stable version) -->
    <script src="https://unpkg.com/lightweight-charts@4.0.1/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        :root {
            --background-surface: #0b1220;
            --background-gradient: radial-gradient(circle at 20% -10%, rgba(59, 130, 246, 0.35), transparent 55%), radial-gradient(circle at 80% -10%, rgba(236, 72, 153, 0.25), transparent 45%), #0b1220;
            --card-bg: rgba(20, 26, 38, 0.75);
            --text-color: #d8dde6;
            --muted-text: #9ba1b3;
            --border-color: rgba(148, 163, 184, 0.08);
            --accent: #3b82f6;
        }

        [data-theme='light'] {
            --background-surface: #f5f7fb;
            --background-gradient: radial-gradient(circle at 20% -10%, rgba(59, 130, 246, 0.2), transparent 55%), radial-gradient(circle at 70% -10%, rgba(236, 72, 153, 0.15), transparent 50%), #f5f7fb;
            --card-bg: rgba(255, 255, 255, 0.8);
            --text-color: #1f2937;
            --muted-text: #6b7280;
            --border-color: rgba(148, 163, 184, 0.18);
            --accent: #2563eb;
        }

        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            background: var(--background-gradient);
            color: var(--text-color);
        }

        header {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.85), rgba(15, 23, 42, 0.55));
            border-bottom: 1px solid var(--border-color);
            backdrop-filter: blur(18px);
        }

        #controls>* {
            background-color: var(--card-bg);
            border-color: var(--border-color);
            color: var(--text-color);
            backdrop-filter: blur(12px);
        }

        #legend,
        #liquidity-slider-container label {
            color: var(--muted-text);
        }

        #slider-value {
            background-color: rgba(59, 130, 246, 0.15);
            color: var(--text-color);
        }

        [data-theme='light'] #slider-value {
            background-color: rgba(59, 130, 246, 0.12);
            color: #1f2937;
        }

        #liquidity-slider {
            accent-color: var(--accent);
            height: 6px;
        }

        #liquidity-slider::-webkit-slider-thumb {
            width: 16px;
            height: 16px;
            border-radius: 999px;
            background: var(--accent);
            border: 2px solid rgba(255, 255, 255, 0.6);
        }

        /* Custom scrollbar for a better look */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(30, 41, 59, 0.45);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(148, 163, 184, 0.45);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(148, 163, 184, 0.7);
        }

        /* Enhanced Heatmap Styles */
        .heatmap-legend {
            display: flex;
            gap: 12px;
            padding: 8px 12px;
            background: rgba(15, 23, 42, 0.6);
            border-radius: 8px;
            font-size: 11px;
            align-items: center;
        }

        .heatmap-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .heatmap-legend-box {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .liquidity-panel {
            position: absolute;
            left: 0;
            top: 0;
            width: 280px;
            height: 100%;
            background: linear-gradient(180deg, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 0.85));
            border-right: 1px solid rgba(148, 163, 184, 0.1);
            padding: 16px;
            overflow-y: auto;
            z-index: 15;
            backdrop-filter: blur(8px);
            display: none;
            flex-direction: column;
            gap: 12px;
        }

        .liquidity-panel.active {
            display: flex;
        }

        [data-theme='light'] .liquidity-panel {
            background: linear-gradient(180deg, rgba(249, 250, 251, 0.95), rgba(243, 244, 246, 0.85));
            border-right: 1px solid rgba(148, 163, 184, 0.2);
        }

        .liquidity-zone-item {
            padding: 10px;
            background: rgba(30, 41, 59, 0.6);
            border-radius: 6px;
            border-left: 3px solid #3b82f6;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .liquidity-zone-item:hover {
            background: rgba(30, 41, 59, 0.9);
            transform: translateX(-2px);
        }

        .liquidity-zone-item.long {
            border-left-color: #10b981;
        }

        .liquidity-zone-item.short {
            border-left-color: #ef4444;
        }

        .zone-price {
            font-weight: 600;
            font-size: 12px;
            font-family: 'Courier New', monospace;
        }

        .zone-value {
            font-size: 11px;
            color: var(--muted-text);
            margin-top: 4px;
        }

        .zone-strength {
            font-size: 10px;
            margin-top: 4px;
            padding: 2px 6px;
            background: rgba(59, 130, 246, 0.2);
            border-radius: 3px;
            display: inline-block;
        }

        #toggle-liquidity-panel {
            position: absolute;
            right: 12px;
            top: 140px;
            z-index: 16;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.3);
            color: var(--text-color);
            width: 32px;
            height: 32px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        #toggle-liquidity-panel:hover {
            background: rgba(59, 130, 246, 0.4);
            transform: scale(1.1);
        }

        .control-button {
            transition: background-color 0.2s ease, color 0.2s ease, transform 0.2s ease;
        }

        .control-button:hover {
            transform: translateY(-1px);
        }

        .control-button.active {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.85), rgba(59, 130, 246, 0.6));
            color: #fff;
            box-shadow: 0 8px 16px rgba(59, 130, 246, 0.2);
        }

        .indicator-label {
            position: absolute;
            left: 12px;
            color: rgba(209, 212, 220, 0.65);
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.02em;
            pointer-events: none;
            /* Allows clicking through the label */
            z-index: 10;
            text-transform: uppercase;
        }

        [data-theme='light'] .indicator-label {
            color: rgba(55, 65, 81, 0.6);
        }
    </style>
</head>

<body class="flex flex-col h-screen antialiased">

    <!-- Header with controls -->
    <header class="p-4 border-b shadow-md">
        <div class="container mx-auto flex flex-col gap-4">
            <div class="flex flex-wrap items-center justify-between gap-4">
                <div class="flex-grow">
                    <h1 class="text-2xl font-bold">Liquidation Zone Heatmap</h1>
                    <div id="legend" class="text-xs flex items-center gap-4 mt-1 flex-wrap">
                        <span>Leyenda:</span>
                        <span class="flex items-center">
                            <div class="w-3 h-0.5 bg-red-500 mr-1"></div> Zonas Activas (Shorts)
                        </span>
                        <span class="flex items-center">
                            <div class="w-3 h-0.5 bg-green-500 mr-1"></div> Zonas Activas (Longs)
                        </span>
                        <span class="flex items-center">
                            <div class="w-3 h-0 border-t-2 border-dashed border-gray-500 mr-1"></div> Liquidaciones
                            Pasadas
                        </span>
                        <span class="flex items-center text-yellow-400">⭐ Más Probable</span>
                    </div>
                </div>
                <div id="controls" class="flex flex-wrap items-center gap-4">
                    <!-- Symbol Selection -->
                    <select id="symbol"
                        class="border rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="BTCUSDT" selected>BTC/USDT</option>
                        <option value="ETHUSDT">ETH/USDT</option>
                        <option value="BNBUSDT">BNB/USDT</option>
                        <option value="SOLUSDT">SOL/USDT</option>
                        <option value="XRPUSDT">XRP/USDT</option>
                        <option value="WLDUSDT">WLD/USDT</option>
                        <option value="COAIUSDT">COAI/USDT</option>
                        <option value="GIGGLEUSDT">GIGGLE/USDT</option>
                    </select>
                    <!-- Interval Selection -->
                    <div id="interval-buttons" class="flex items-center border rounded-lg p-1">
                        <button class="interval-btn control-button px-3 py-1 rounded-md text-sm font-medium"
                            data-interval="1m">1m</button>
                        <button class="interval-btn control-button px-3 py-1 rounded-md text-sm font-medium"
                            data-interval="5m">5m</button>
                        <button class="interval-btn control-button px-3 py-1 rounded-md text-sm font-medium"
                            data-interval="15m">15m</button>
                        <button class="interval-btn control-button px-3 py-1 rounded-md text-sm font-medium"
                            data-interval="1h">1H</button>
                        <button class="interval-btn control-button px-3 py-1 rounded-md text-sm font-medium active"
                            data-interval="4h">4H</button>
                        <button class="interval-btn control-button px-3 py-1 rounded-md text-sm font-medium"
                            data-interval="1d">1D</button>
                    </div>
                    <!-- Leverage Selection -->
                    <div id="leverage-buttons" class="flex items-center border rounded-lg p-1">
                        <button class="leverage-btn control-button px-2 py-1 rounded-md text-sm font-medium"
                            data-leverage="5">5x</button>
                        <button class="leverage-btn control-button px-2 py-1 rounded-md text-sm font-medium"
                            data-leverage="10">10x</button>
                        <button class="leverage-btn control-button px-2 py-1 rounded-md text-sm font-medium"
                            data-leverage="25">25x</button>
                        <button class="leverage-btn control-button px-2 py-1 rounded-md text-sm font-medium active"
                            data-leverage="50">50x</button>
                        <button class="leverage-btn control-button px-2 py-1 rounded-md text-sm font-medium"
                            data-leverage="100">100x</button>
                    </div>
                    <!-- Drawing Tool -->
                    <button id="draw-line-tool"
                        class="control-button p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                        title="Dibujar línea horizontal">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24"
                            stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M4 8h16M4 16h16" />
                        </svg>
                    </button>
                    <div id="loader"
                        class="hidden w-6 h-6 border-4 border-blue-500 border-t-transparent border-solid rounded-full animate-spin">
                    </div>
                    <!-- Theme Toggle -->
                    <button id="theme-toggle"
                        class="p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <svg id="theme-icon-light" class="h-5 w-5 hidden" fill="none" viewBox="0 0 24 24"
                            stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z">
                            </path>
                        </svg>
                        <svg id="theme-icon-dark" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z">
                            </path>
                        </svg>
                    </button>
                </div>
            </div>
            <!-- Liquidity Concentration Slider -->
            <div id="liquidity-slider-container" class="flex items-center gap-3 text-sm pt-2">
                <label for="liquidity-slider" class="whitespace-nowrap">Concentraci�n de Liquidez:</label>
                <input type="range" id="liquidity-slider" min="0" max="100" step="1" value="0"
                    class="w-full rounded-full appearance-none cursor-pointer">
                <span id="slider-value" class="font-mono px-2 py-1 rounded-md">Todos</span>
            </div>
        </div>
    </header>

    <!-- Chart Container -->
    <main class="flex-grow relative">
        <div id="chart-container" class="absolute top-0 left-0 w-full h-full">
            <!-- Error Message Overlay -->
            <div id="error-overlay"
                class="hidden absolute inset-0 bg-red-900 bg-opacity-75 flex flex-col items-center justify-center text-center p-8 z-20">
                <h3 class="text-2xl font-bold text-red-200">Error de Carga de Datos</h3>
                <p id="error-message" class="text-red-300 mt-2">No se pudieron obtener los datos esenciales del mercado.
                    Esto puede ser un problema temporal con la API. Por favor, intente seleccionar otro par o recargar
                    la página en unos momentos.</p>
            </div>
            <!-- Indicator Labels -->
            <div id="indicator-labels" class="absolute top-0 left-0 w-full h-full pointer-events-none">
                <div class="indicator-label" style="top: 61%;">Volumen</div>
                <div class="indicator-label" style="top: 71%;">Interés Abierto (OI)</div>
                <div class="indicator-label" style="top: 81%;">Liquidaciones</div>
                <div class="indicator-label" style="top: 91%;">Ratio OI/VOL</div>
            </div>
            <!-- Toggle Liquidity Panel Button -->
            <button id="toggle-liquidity-panel" title="Toggle liquidity zones panel">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24"
                    stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M13 5l7 7-7 7M5 5l7 7-7 7" />
                </svg>
            </button>
            <!-- Liquidity Info Panel -->
            <div id="liquidity-panel" class="liquidity-panel">
                <div style="padding-bottom: 8px; border-bottom: 1px solid rgba(148, 163, 184, 0.1);">
                    <h3 style="font-weight: 600; font-size: 13px; margin-bottom: 4px;">Zonas de Liquidez</h3>
                    <div style="font-size: 10px; color: var(--muted-text);">Longs activos / Shorts activos</div>
                </div>
                <div id="liquidity-zones-container" style="flex: 1; overflow-y: auto;"></div>
            </div>

            <!-- Cluster Legend -->
            <div id="cluster-legend"
                style="position: absolute; top: 80px; right: 20px; background: rgba(15, 23, 42, 0.95); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; padding: 12px 14px; font-size: 11px; z-index: 10; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);">
                <div style="font-weight: 600; margin-bottom: 10px; font-size: 12px; color: #f1f5f9;">Clusters de
                    Liquidación</div>

                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                    <div
                        style="width: 24px; height: 16px; background: linear-gradient(to bottom, rgba(220, 38, 38, 0.75), rgba(220, 38, 38, 0.15)); border: 1.5px solid rgba(220, 38, 38, 0.9); border-radius: 2px;">
                    </div>
                    <div style="flex: 1;">
                        <div style="font-weight: 500; color: #fca5a5;">Shorts (Resistencia)</div>
                        <div style="font-size: 9px; color: rgba(148, 163, 184, 0.9); margin-top: 2px;">Precio ↑ liquida
                            shorts</div>
                    </div>
                </div>

                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                    <div
                        style="width: 24px; height: 16px; background: linear-gradient(to bottom, rgba(20, 184, 166, 0.75), rgba(20, 184, 166, 0.15)); border: 1.5px solid rgba(20, 184, 166, 0.9); border-radius: 2px;">
                    </div>
                    <div style="flex: 1;">
                        <div style="font-weight: 500; color: #5eead4;">Longs (Soporte)</div>
                        <div style="font-size: 9px; color: rgba(148, 163, 184, 0.9); margin-top: 2px;">Precio ↓ liquida
                            longs</div>
                    </div>
                </div>

                <div
                    style="padding-top: 8px; border-top: 1px solid rgba(148, 163, 184, 0.15); font-size: 10px; color: rgba(148, 163, 184, 0.85);">
                    <div style="margin-bottom: 4px;">💡 <span style="font-weight: 500;">Intensidad:</span></div>
                    <div style="font-size: 9px; color: rgba(148, 163, 184, 0.75);">Más oscuro = Mayor liquidez</div>
                    <div style="font-size: 9px; color: rgba(148, 163, 184, 0.75);">Gradiente = Concentración</div>
                </div>
            </div>

            <!-- Analytics Panel -->
            <div id="analytics-panel"
                style="position: absolute; bottom: 20px; right: 20px; background: rgba(15, 23, 42, 0.95); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; padding: 14px 16px; font-size: 11px; z-index: 10; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); max-width: 280px;">
                <div
                    style="font-weight: 600; margin-bottom: 12px; font-size: 12px; color: #f1f5f9; display: flex; justify-content: space-between; align-items: center;">
                    <span>📊 Cluster Analytics</span>
                    <button onclick="updateAnalyticsUI()"
                        style="background: none; border: none; color: #94a3b8; cursor: pointer; font-size: 14px; padding: 0;"
                        title="Refresh">🔄</button>
                </div>

                <!-- Basic Stats -->
                <div
                    style="margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid rgba(148, 163, 184, 0.1);">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <span style="color: rgba(148, 163, 184, 0.9);">Total Tracked:</span>
                        <span id="total-tracked" style="font-weight: 600; color: #f1f5f9;">0</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <span style="color: rgba(148, 163, 184, 0.9);">Touched:</span>
                        <span id="total-touched" style="font-weight: 600; color: #60a5fa;">0 (0%)</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: rgba(148, 163, 184, 0.9);">Bounce Rate:</span>
                        <span id="bounce-rate" style="font-weight: 600; color: #34d399;">0%</span>
                    </div>
                </div>

                <!-- Outcome Breakdown -->
                <div
                    style="margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid rgba(148, 163, 184, 0.1);">
                    <div style="font-weight: 500; margin-bottom: 6px; font-size: 10px; color: #cbd5e1;">Outcomes:</div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 10px;">
                        <span style="color: rgba(148, 163, 184, 0.85);">Strong Bounce:</span>
                        <span id="strong-bounce" style="color: #10b981;">0 (0%)</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 10px;">
                        <span style="color: rgba(148, 163, 184, 0.85);">Weak Bounce:</span>
                        <span id="weak-bounce" style="color: #3b82f6;">0 (0%)</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 10px;">
                        <span style="color: rgba(148, 163, 184, 0.85);">Breakthrough:</span>
                        <span id="breakthrough" style="color: #ef4444;">0 (0%)</span>
                    </div>
                </div>

                <!-- Performance by Side -->
                <div
                    style="margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid rgba(148, 163, 184, 0.1);">
                    <div style="font-weight: 500; margin-bottom: 6px; font-size: 10px; color: #cbd5e1;">Performance by
                        Side:</div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 10px;">
                        <span style="color: #5eead4;">Longs:</span>
                        <span id="long-performance" style="color: #5eead4;">0% (0/0)</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 10px;">
                        <span style="color: #fca5a5;">Shorts:</span>
                        <span id="short-performance" style="color: #fca5a5;">0% (0/0)</span>
                    </div>
                </div>

                <!-- Performance by Intensity -->
                <div
                    style="margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid rgba(148, 163, 184, 0.1);">
                    <div style="font-weight: 500; margin-bottom: 6px; font-size: 10px; color: #cbd5e1;">By Intensity:
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 10px;">
                        <span style="color: rgba(148, 163, 184, 0.85);">High (>70%):</span>
                        <span id="high-intensity" style="color: #f1f5f9;">0% (0)</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 10px;">
                        <span style="color: rgba(148, 163, 184, 0.85);">Med (40-70%):</span>
                        <span id="med-intensity" style="color: #f1f5f9;">0% (0)</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 10px;">
                        <span style="color: rgba(148, 163, 184, 0.85);">Low (<40%):< /span>
                                <span id="low-intensity" style="color: #f1f5f9;">0% (0)</span>
                    </div>
                </div>

                <!-- Key Metric -->
                <div
                    style="margin-bottom: 12px; padding: 8px; background: rgba(59, 130, 246, 0.1); border-radius: 4px; border: 1px solid rgba(59, 130, 246, 0.2);">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-weight: 600; color: #60a5fa; font-size: 10px;">Avg Bounce:</span>
                        <span id="avg-bounce" style="font-weight: 700; color: #60a5fa; font-size: 14px;">0%</span>
                    </div>
                </div>

                <!-- Export Button -->
                <button onclick="exportAnalytics()"
                    style="width: 100%; padding: 8px; background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 11px; font-weight: 600; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); transition: all 0.2s;">
                    📥 Export to CSV
                </button>
            </div>
        </div>
    </main>

    <script>
        // --- DOM Elements ---
        const chartContainer = document.getElementById('chart-container');
        const symbolSelector = document.getElementById('symbol');
        const intervalButtonsContainer = document.getElementById('interval-buttons');
        const leverageButtonsContainer = document.getElementById('leverage-buttons');
        const liquiditySlider = document.getElementById('liquidity-slider');
        const sliderValueEl = document.getElementById('slider-value');
        const loader = document.getElementById('loader');
        const themeToggle = document.getElementById('theme-toggle');
        const themeIconLight = document.getElementById('theme-icon-light');
        const themeIconDark = document.getElementById('theme-icon-dark');
        const errorOverlay = document.getElementById('error-overlay');
        const errorMessageEl = document.getElementById('error-message');
        const drawLineTool = document.getElementById('draw-line-tool');
        const liquidityPanel = document.getElementById('liquidity-panel');
        const togglePanelBtn = document.getElementById('toggle-liquidity-panel');
        const liquidityZonesContainer = document.getElementById('liquidity-zones-container');

        const heatmapOverlayCanvas = document.createElement('canvas');
        heatmapOverlayCanvas.id = 'liquidity-heatmap-overlay';
        heatmapOverlayCanvas.style.position = 'absolute';
        heatmapOverlayCanvas.style.top = '0';
        heatmapOverlayCanvas.style.left = '0';
        heatmapOverlayCanvas.style.right = '0';
        heatmapOverlayCanvas.style.bottom = '0';
        heatmapOverlayCanvas.style.width = '100%';
        heatmapOverlayCanvas.style.height = '100%';
        heatmapOverlayCanvas.style.pointerEvents = 'none';
        heatmapOverlayCanvas.style.zIndex = '6';
        chartContainer.appendChild(heatmapOverlayCanvas);
        const heatmapOverlayCtx = heatmapOverlayCanvas.getContext('2d');

        // --- Chart State ---
        let chart;
        let candlestickSeries, volumeSeries, openInterestSeries, longLiqsSeries, shortLiqsSeries, oiVolRatioSeries;
        let heatmapLongSeries = [], heatmapShortSeries = [];
        let historicalPriceLines = [], activePriceLines = [], userDrawnLines = [];
        let historicalLiquidityZones = [];
        let fetchedData = { klines: [], openInterest: [], liquidations: [], longLiqs: [], shortLiqs: [] };
        const HEATMAP_SERIES_COUNT = 150;
        const VISIBLE_LABELS_COUNT = 0;
        const FUTURE_BARS_PROJECTION = 10;

        let currentSymbol = 'BTCUSDT';
        let currentInterval = '4h';
        let selectedLeverages = [50];
        let liquidityThresholdPct = 0;
        let maxLiquidityObserved = 0;
        let latestHeatmapClusters = { long: [], short: [] };
        let historicalHeatmapClusters = { long: [], short: [] };  // Clusters from past candles
        let clusterTrackingDB = null;  // IndexedDB for cluster tracking
        let trackingEnabled = true;    // Enable/disable tracking
        let isUpdating = false;
        let isDrawingMode = false;
        let shouldAutoFitOnNextRender = true;
        let suppressTimeScaleTracking = false;
        let userHasCustomTimeScale = false;

        const bybitKlineIntervalMap = {
            '1m': '1m',
            '5m': '5m',
            '15m': '15m',
            '1h': '1h',
            '4h': '4h',
            '1d': '1d'
        };

        const bybitOpenInterestIntervalMap = {
            '1m': '5min',
            '5m': '5min',
            '15m': '15min',
            '1h': '1h',
            '4h': '4h',
            '1d': '1d'
        };

        const intervalToSeconds = {
            '1m': 60,
            '5m': 5 * 60,
            '15m': 15 * 60,
            '1h': 60 * 60,
            '4h': 4 * 60 * 60,
            '1d': 24 * 60 * 60
        };

        // --- Theme Options ---
        const themes = {
            dark: {
                chart: {
                    layout: { backgroundColor: '#0f172a', textColor: '#e2e8f0' },
                    grid: { vertLines: { visible: false }, horzLines: { visible: false } }
                },
                candlestick: {
                    upColor: '#10b981',
                    downColor: '#f97316',
                    borderDownColor: '#fb7185',
                    borderUpColor: '#34d399',
                    wickDownColor: '#fb7185',
                    wickUpColor: '#34d399'
                },
                volume: (close, open) => close >= open ? 'rgba(16, 185, 129, 0.55)' : 'rgba(249, 115, 22, 0.55)'
            },
            light: {
                chart: {
                    layout: { backgroundColor: '#ffffff', textColor: '#1f2937' },
                    grid: { vertLines: { visible: false }, horzLines: { visible: false } }
                },
                candlestick: {
                    upColor: '#0ea5e9',
                    downColor: '#f87171',
                    borderDownColor: '#ef4444',
                    borderUpColor: '#38bdf8',
                    wickDownColor: '#f87171',
                    wickUpColor: '#38bdf8'
                },
                volume: (close, open) => close >= open ? 'rgba(59, 130, 246, 0.45)' : 'rgba(239, 68, 68, 0.45)'
            }
        };
        let currentTheme = 'dark';

        function applyTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            const themeOptions = themes[theme];
            if (chart && candlestickSeries) {
                chart.applyOptions(themeOptions.chart);
                candlestickSeries.applyOptions(themeOptions.candlestick);
                if (fetchedData.klines && fetchedData.klines.length > 0) {
                    const volumeData = fetchedData.klines.map(k => ({ time: k.time, value: k.volume, color: themeOptions.volume(k.close, k.open) }));
                    volumeSeries.setData(volumeData);
                }
            }
            themeIconLight.classList.toggle('hidden', theme === 'dark');
            themeIconDark.classList.toggle('hidden', theme === 'light');
            drawOverlayClusters();
        }

        function initializeChart() {
            chartContainer.style.position = chartContainer.style.position || 'relative';

            chart = LightweightCharts.createChart(chartContainer, {
                width: chartContainer.clientWidth,
                height: chartContainer.clientHeight,
                layout: {
                    backgroundColor: '#131722',
                    textColor: '#d1d4dc',
                    fontFamily: 'Inter, system-ui, sans-serif'
                },
                grid: {
                    vertLines: { color: 'rgba(255, 255, 255, 0.04)', visible: true },
                    horzLines: { color: 'rgba(255, 255, 255, 0.04)', visible: true }
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                    vertLine: {
                        color: 'rgba(150, 154, 170, 0.35)',
                        width: 1,
                        labelBackgroundColor: '#1f2937'
                    },
                    horzLine: {
                        color: 'rgba(150, 154, 170, 0.35)',
                        width: 1,
                        labelBackgroundColor: '#1f2937'
                    }
                },
                rightPriceScale: {
                    borderVisible: false,
                    scaleMargins: { top: 0.05, bottom: 0.25 }
                },
                timeScale: {
                    borderColor: '#485c7b',
                    timeVisible: true,
                    secondsVisible: false,
                    rightOffset: 8,
                    barSpacing: 9,
                    fixLeftEdge: false,
                    lockVisibleTimeRangeOnResize: true
                },
                handleScroll: {
                    vertTouchDrag: true,
                    mouseWheel: true,
                    pressedMouseMove: true
                },
                handleScale: {
                    axisPressedMouseMove: true,
                    mouseWheel: true,
                    pinch: true
                }
            });

            candlestickSeries = chart.addCandlestickSeries({ upColor: '#26a69a', downColor: '#ef5350', borderDownColor: '#ef5350', borderUpColor: '#26a69a', wickDownColor: '#ef5350', wickUpColor: '#26a69a', priceScaleId: 'right' });

            const mainPaneHeight = 0.6;
            const indicatorPaneHeight = (1 - mainPaneHeight) / 4;

            volumeSeries = chart.addHistogramSeries({ priceFormat: { type: 'volume' }, priceScaleId: 'volume', scaleMargins: { top: mainPaneHeight, bottom: 1 - (mainPaneHeight + indicatorPaneHeight) } });
            chart.priceScale('volume').applyOptions({ scaleMargins: { top: mainPaneHeight, bottom: 1 - (mainPaneHeight + indicatorPaneHeight) } });

            openInterestSeries = chart.addLineSeries({ color: '#2962FF', lineWidth: 2, priceScaleId: 'oi', scaleMargins: { top: mainPaneHeight + indicatorPaneHeight, bottom: 1 - (mainPaneHeight + 2 * indicatorPaneHeight) } });
            chart.priceScale('oi').applyOptions({ scaleMargins: { top: mainPaneHeight + indicatorPaneHeight, bottom: 1 - (mainPaneHeight + 2 * indicatorPaneHeight) } });

            longLiqsSeries = chart.addHistogramSeries({ color: 'rgba(239, 83, 80, 0.7)', priceFormat: { type: 'volume' }, priceScaleId: 'liquidations', scaleMargins: { top: mainPaneHeight + 2 * indicatorPaneHeight, bottom: 1 - (mainPaneHeight + 3 * indicatorPaneHeight) } });
            shortLiqsSeries = chart.addHistogramSeries({ color: 'rgba(38, 166, 154, 0.7)', priceFormat: { type: 'volume' }, priceScaleId: 'liquidations', scaleMargins: { top: mainPaneHeight + 2 * indicatorPaneHeight, bottom: 1 - (mainPaneHeight + 3 * indicatorPaneHeight) } });
            chart.priceScale('liquidations').applyOptions({ scaleMargins: { top: mainPaneHeight + 2 * indicatorPaneHeight, bottom: 1 - (mainPaneHeight + 3 * indicatorPaneHeight) } });

            oiVolRatioSeries = chart.addLineSeries({ color: '#facc15', lineWidth: 2, priceScaleId: 'oi_vol_ratio', scaleMargins: { top: mainPaneHeight + 3 * indicatorPaneHeight, bottom: 0 } });
            chart.priceScale('oi_vol_ratio').applyOptions({ scaleMargins: { top: mainPaneHeight + 3 * indicatorPaneHeight, bottom: 0 } });

            for (let i = 0; i < HEATMAP_SERIES_COUNT; i++) {
                const commonOptions = { priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false, priceScaleId: 'right' };
                heatmapLongSeries.push(chart.addLineSeries(commonOptions));
                heatmapShortSeries.push(chart.addLineSeries(commonOptions));
            }

            chart.timeScale().subscribeVisibleLogicalRangeChange((range) => {
                if (suppressTimeScaleTracking || !range || range.from === null || range.to === null) return;
                userHasCustomTimeScale = true;
                drawOverlayClusters();  // Redraw clusters on scroll/zoom
            });

            resizeHeatmapOverlay();
            ensureOverlayOnTop();
        }

        function normalizeTimestamp(raw) {
            if (typeof raw === 'number') {
                return raw > 1e12 ? Math.floor(raw / 1000) : Math.floor(raw);
            }
            if (typeof raw === 'string' && raw.trim() !== '') {
                const numericCandidate = Number(raw);
                if (!Number.isNaN(numericCandidate)) {
                    return numericCandidate > 1e12 ? Math.floor(numericCandidate / 1000) : Math.floor(numericCandidate);
                }
                const parsedDate = new Date(raw);
                if (!Number.isNaN(parsedDate.getTime())) {
                    return Math.floor(parsedDate.getTime() / 1000);
                }
            }
            return null;
        }

        function toNumber(value, fallback = 0) {
            if (value === null || value === undefined || value === '') return fallback;
            const numeric = Number(value);
            return Number.isFinite(numeric) ? numeric : fallback;
        }

        const releaseTimeScaleTracking = () => {
            const enable = () => { suppressTimeScaleTracking = false; };
            if (typeof requestAnimationFrame === 'function') {
                requestAnimationFrame(enable);
            } else {
                setTimeout(enable, 0);
            }
        };

        const runWithTimeScaleLock = (fn) => {
            suppressTimeScaleTracking = true;
            try {
                fn();
            } finally {
                releaseTimeScaleTracking();
            }
        };

        const resetUserTimeScalePreference = () => {
            userHasCustomTimeScale = false;
            shouldAutoFitOnNextRender = true;
        };

        const maybeAutoFitTimeScale = () => {
            if (!chart || typeof chart.timeScale !== 'function' || userHasCustomTimeScale || !shouldAutoFitOnNextRender) return;
            const timeScaleApi = chart.timeScale();
            if (!timeScaleApi) return;
            runWithTimeScaleLock(() => timeScaleApi.fitContent());
            shouldAutoFitOnNextRender = false;
        };

        const formatLiquidityValue = (value) => {
            if (!value || value <= 0) return '$0';
            if (value >= 1e9) return `$${(value / 1e9).toFixed(2)}B`;
            if (value >= 1e6) return `$${(value / 1e6).toFixed(2)}M`;
            if (value >= 1e3) return `$${(value / 1e3).toFixed(2)}K`;
            return `$${value.toFixed(0)}`;
        };

        const updateLiquiditySliderLabel = () => {
            const thresholdValue = maxLiquidityObserved * liquidityThresholdPct;
            if (!maxLiquidityObserved || liquidityThresholdPct === 0) {
                sliderValueEl.textContent = 'Todos';
                return;
            }
            sliderValueEl.textContent = formatLiquidityValue(thresholdValue);
        };

        const resizeHeatmapOverlay = () => {
            if (!heatmapOverlayCanvas) return;
            const dpr = window.devicePixelRatio || 1;
            const width = chartContainer.clientWidth;
            const height = chartContainer.clientHeight;
            heatmapOverlayCanvas.width = Math.max(1, Math.floor(width * dpr));
            heatmapOverlayCanvas.height = Math.max(1, Math.floor(height * dpr));
            heatmapOverlayCanvas.style.width = `${width}px`;
            heatmapOverlayCanvas.style.height = `${height}px`;
        };

        const ensureOverlayOnTop = () => {
            if (!chartContainer || !heatmapOverlayCanvas) return;
            heatmapOverlayCanvas.style.zIndex = '20';
            chartContainer.appendChild(heatmapOverlayCanvas);
        };

        const HEATMAP_COLOR_STOPS_ACTIVE = [
            { stop: 0, color: [15, 23, 42] },      // deep slate
            { stop: 0.25, color: [8, 145, 178] },  // teal
            { stop: 0.5, color: [34, 197, 94] },   // green
            { stop: 0.75, color: [234, 179, 8] },  // amber
            { stop: 1, color: [244, 63, 94] }      // red
        ];

        const HEATMAP_COLOR_STOPS_HISTORICAL = [
            { stop: 0, color: [15, 23, 42] },      // slate
            { stop: 0.3, color: [56, 189, 248] },  // cyan
            { stop: 0.6, color: [129, 140, 248] }, // indigo
            { stop: 1, color: [244, 114, 182] }    // pink
        ];

        const HEATMAP_COLOR_STOPS_LONG = [
            { stop: 0, color: [15, 23, 42] },      // dark slate
            { stop: 0.3, color: [20, 184, 166] },  // teal-500
            { stop: 0.6, color: [13, 148, 136] },  // teal-600
            { stop: 1, color: [15, 118, 110] }     // teal-700
        ];

        const HEATMAP_COLOR_STOPS_SHORT = [
            { stop: 0, color: [15, 23, 42] },      // dark slate
            { stop: 0.3, color: [220, 38, 38] },   // red-700
            { stop: 0.6, color: [185, 28, 28] },   // red-800
            { stop: 1, color: [153, 27, 27] }      // red-900
        ];

        const interpolateColor = (stops, t) => {
            if (t <= 0) return stops[0].color;
            if (t >= 1) return stops[stops.length - 1].color;
            for (let i = 0; i < stops.length - 1; i++) {
                const current = stops[i];
                const next = stops[i + 1];
                if (t >= current.stop && t <= next.stop) {
                    const localT = (t - current.stop) / (next.stop - current.stop);
                    return current.color.map((value, idx) => Math.round(value + (next.color[idx] - value) * localT));
                }
            }
            return stops[stops.length - 1].color;
        };

        const heatmapColorForValue = (value, stops = HEATMAP_COLOR_STOPS_ACTIVE) => {
            const normalized = Math.min(1, Math.max(0, value));
            const eased = Math.pow(normalized, 0.35); // boost contrast on small values
            const [r, g, b] = interpolateColor(stops, eased);
            const alpha = 0.15 + eased * 0.35;
            return `rgba(${r}, ${g}, ${b}, ${alpha.toFixed(3)})`;
        };

        const drawOverlayClusters = (() => {
            let framePending = false;
            const schedule = typeof requestAnimationFrame === 'function'
                ? requestAnimationFrame
                : (cb) => setTimeout(cb, 0);

            const render = () => {
                if (!heatmapOverlayCtx || !candlestickSeries || !chart) return;
                resizeHeatmapOverlay();
                ensureOverlayOnTop();
                const dpr = window.devicePixelRatio || 1;
                const ctx = heatmapOverlayCtx;
                const timeScale = chart.timeScale();
                ctx.save();
                ctx.clearRect(0, 0, heatmapOverlayCanvas.width, heatmapOverlayCanvas.height);

                if (!timeScale) {
                    ctx.restore();
                    return;
                }

                const toCoord = (value) => (typeof value === 'number' ? value : null);
                const priceScale = chart.priceScale('right');
                const scaleOptions = (typeof priceScale?.options === 'function'
                    ? priceScale.options()
                    : priceScale?.options) || {};
                const scaleMargins = scaleOptions.scaleMargins || { top: 0, bottom: 0 };
                const paneTop = heatmapOverlayCanvas.height * (scaleMargins.top ?? 0);
                const paneBottom = heatmapOverlayCanvas.height * (1 - (scaleMargins.bottom ?? 0));
                const paneHeight = Math.max(10, paneBottom - paneTop);

                const estimateBarSpacingPx = () => {
                    if (!timeScale) return 10;
                    const logicalRange = timeScale.getVisibleLogicalRange ? timeScale.getVisibleLogicalRange() : null;
                    if (logicalRange && Number.isFinite(logicalRange.from) && Number.isFinite(logicalRange.to)) {
                        const bars = Math.max(1, logicalRange.to - logicalRange.from);
                        return (chartContainer.clientWidth / bars);
                    }
                    const opts = typeof timeScale.options === 'function' ? timeScale.options() : null;
                    return opts?.barSpacing || 10;
                };

                const resolveTimeRange = (startTime, endTime, fallbackBars = 0) => {
                    const startCoord = toCoord(timeScale.timeToCoordinate(startTime));
                    let endCoord = toCoord(timeScale.timeToCoordinate(endTime));
                    if ((endCoord === null || endCoord === undefined) && startCoord !== null && fallbackBars > 0) {
                        endCoord = startCoord + estimateBarSpacingPx() * fallbackBars;
                    }
                    return { startCoord, endCoord };
                };

                const allIntensities = [maxLiquidityObserved || 0];
                historicalLiquidityZones.forEach(zone => allIntensities.push(zone.totalValue || 0));
                latestHeatmapClusters.long.forEach(cluster => allIntensities.push(cluster.totalValue || 0));
                latestHeatmapClusters.short.forEach(cluster => allIntensities.push(cluster.totalValue || 0));
                const maxHeatmapValue = Math.max(1, ...allIntensities);
                const normalizeIntensity = (value) => Math.min(1, Math.max(0, value / maxHeatmapValue));

                const drawHeatmapBlock = ({ startCoord, endCoord, topCoord, bottomCoord, intensity, side, palette, isHistorical = false }) => {
                    if (
                        topCoord === null || topCoord === undefined ||
                        bottomCoord === null || bottomCoord === undefined
                    ) {
                        return;
                    }
                    const hasStart = startCoord !== null && startCoord !== undefined;
                    let resolvedStart = hasStart ? startCoord : 0;
                    let resolvedEnd = endCoord;
                    if ((resolvedEnd === null || resolvedEnd === undefined) && hasStart) {
                        resolvedEnd = resolvedStart + estimateBarSpacingPx() * FUTURE_BARS_PROJECTION;
                    }
                    if (!hasStart && !isHistorical) return;

                    const x = Math.min(resolvedStart, resolvedEnd) * dpr;
                    const width = Math.max(8 * dpr, Math.abs(resolvedEnd - resolvedStart) * dpr);
                    const top = Math.min(topCoord, bottomCoord) * dpr;
                    const height = Math.max(2 * dpr, Math.abs(topCoord - bottomCoord) * dpr);

                    // HORIZONTAL gradient (left to right) for visibility on thin clusters
                    const gradient = ctx.createLinearGradient(x, 0, x + width, 0);
                    const [r, g, b] = interpolateColor(palette, Math.min(1, intensity));

                    // Pronounced horizontal gradient: left opaque → right transparent
                    const alphaLeft = isHistorical
                        ? 0.20 + intensity * 0.45
                        : 0.35 + intensity * 0.60;
                    const alphaMid = alphaLeft * 0.60;
                    const alphaRight = alphaLeft * 0.15;  // Very transparent on right

                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${alphaLeft})`);
                    gradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, ${alphaMid})`);
                    gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, ${alphaRight})`);

                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, top, width, height);

                    // Outer glow effect for depth
                    if (!isHistorical && intensity > 0.3) {
                        ctx.shadowColor = side === 'long'
                            ? `rgba(20, 184, 166, ${0.4 * intensity})`
                            : `rgba(220, 38, 38, ${0.4 * intensity})`;
                        ctx.shadowBlur = 8 * dpr;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                    }

                    // STRONGER border for better definition
                    ctx.strokeStyle = side === 'long'
                        ? `rgba(20, 184, 166, ${0.75 + intensity * 0.25})`  // More opaque
                        : `rgba(220, 38, 38, ${0.75 + intensity * 0.25})`;
                    ctx.lineWidth = (2 + intensity * 2.5) * dpr;  // Thicker
                    ctx.strokeRect(x, top, width, height);

                    // Reset shadow
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;

                    // Subtle inner highlight for professional depth
                    if (intensity > 0.5) {
                        ctx.strokeStyle = `rgba(255, 255, 255, ${0.15 * intensity})`;
                        ctx.lineWidth = 1 * dpr;
                        ctx.strokeRect(x + 2 * dpr, top + 2 * dpr, width - 4 * dpr, height - 4 * dpr);
                    }
                };

                ctx.save();
                ctx.beginPath();
                ctx.rect(0, paneTop, heatmapOverlayCanvas.width, paneHeight);
                ctx.clip();

                // Render with clean, professional appearance
                ctx.globalCompositeOperation = 'source-over';
                ctx.filter = 'none';

                const renderHistoricalHeatmap = () => {
                    if (!historicalLiquidityZones.length) return;
                    historicalLiquidityZones.forEach(zone => {
                        const { startCoord, endCoord } = resolveTimeRange(zone.startTime, zone.endTime, 1);
                        const topCoord = toCoord(candlestickSeries.priceToCoordinate(zone.high));
                        const bottomCoord = toCoord(candlestickSeries.priceToCoordinate(zone.low));

                        const palette = zone.side === 'long' ? HEATMAP_COLOR_STOPS_LONG : HEATMAP_COLOR_STOPS_SHORT;
                        drawHeatmapBlock({
                            startCoord,
                            endCoord,
                            topCoord,
                            bottomCoord,
                            intensity: normalizeIntensity(zone.totalValue || 0) * 0.6,
                            side: zone.side,
                            palette,
                            isHistorical: true
                        });
                    });
                };

                const renderActiveHeatmap = () => {
                    const renderCollection = (collection, side, isHistorical = false) => {
                        collection.forEach(cluster => {
                            const { startCoord, endCoord } = resolveTimeRange(
                                cluster.startTime,
                                cluster.endTime,
                                FUTURE_BARS_PROJECTION
                            );
                            const topCoord = toCoord(candlestickSeries.priceToCoordinate(cluster.maxPrice));
                            const bottomCoord = toCoord(candlestickSeries.priceToCoordinate(cluster.minPrice));

                            const palette = side === 'long' ? HEATMAP_COLOR_STOPS_LONG : HEATMAP_COLOR_STOPS_SHORT;
                            drawHeatmapBlock({
                                startCoord,
                                endCoord,
                                topCoord,
                                bottomCoord,
                                intensity: normalizeIntensity(cluster.totalValue || 0),
                                side,
                                palette,
                                isHistorical
                            });
                        });
                    };

                    // Render active clusters (from last candle)
                    renderCollection(latestHeatmapClusters.long, 'long', false);
                    renderCollection(latestHeatmapClusters.short, 'short', false);

                    // Render historical clusters (from past candles)
                    renderCollection(historicalHeatmapClusters.long, 'long', true);
                    renderCollection(historicalHeatmapClusters.short, 'short', true);
                };

                renderHistoricalHeatmap();
                ctx.filter = 'blur(0px)';
                ctx.globalCompositeOperation = 'source-over';

                renderActiveHeatmap();

                ctx.globalCompositeOperation = 'source-over';
                ctx.filter = 'none';
                ctx.restore();

                ctx.restore();
            };

            return () => {
                if (framePending) return;
                framePending = true;
                schedule(() => {
                    framePending = false;
                    render();
                });
            };
        })();

        function resolveLiquidationSide(entry) {
            const side = entry?.m ?? entry?.side ?? entry?.direction ?? entry?.positionSide;
            if (typeof side === 'string') {
                const normalized = side.toLowerCase();
                if (normalized.includes('short') || normalized.includes('sell')) return 'short';
                if (normalized.includes('long') || normalized.includes('buy')) return 'long';
            } else if (typeof side === 'boolean') {
                return side ? 'short' : 'long';
            } else if (typeof side === 'number') {
                return side < 0 ? 'short' : 'long';
            }
            return 'long';
        }

        async function fetchFromProxy(endpoint, params) {
            const url = new URL(`/api/coinalyze`, window.location.origin);
            url.searchParams.append('endpoint', endpoint);
            for (const key in params) {
                url.searchParams.append(key, params[key]);
            }

            console.log(`Requesting data from proxy: ${url}`);

            const response = await fetch(url);
            const responseBody = await response.text();

            if (!response.ok) {
                console.error('Proxy Error Response:', responseBody);
                throw new Error(`Proxy API Error for ${endpoint}: ${response.status} ${response.statusText} - ${responseBody}`);
            }

            try {
                const data = JSON.parse(responseBody);
                console.log(`Data received for ${endpoint}:`, data);
                return data;
            } catch (e) {
                console.error('Failed to parse JSON from proxy:', responseBody);
                throw new Error('Received non-JSON response from server.');
            }
        }

        async function fetchKlines(symbol, interval, from, to) {
            const bybitInterval = bybitKlineIntervalMap[interval] || interval;
            const data = await fetchFromProxy('ohlcv', { symbol, interval: bybitInterval, startTime: from, endTime: to, limit: 500 });
            const candles = data?.candles;
            if (!Array.isArray(candles) || candles.length === 0) {
                throw new Error(`Bybit kline API did not return data. Response: ${JSON.stringify(data)}`);
            }
            return candles.map(entry => {
                const time = normalizeTimestamp(entry.openTime ?? entry.time ?? entry.t);
                if (!time) return null;
                return {
                    time,
                    open: toNumber(entry.open ?? entry.o),
                    high: toNumber(entry.high ?? entry.h),
                    low: toNumber(entry.low ?? entry.l),
                    close: toNumber(entry.close ?? entry.c),
                    volume: toNumber(entry.volume ?? entry.v ?? entry.quoteVolume)
                };
            }).filter(Boolean).sort((a, b) => a.time - b.time);
        }

        async function fetchOpenInterest(symbol, interval, from, to) {
            const bybitInterval = bybitOpenInterestIntervalMap[interval] || interval;
            const data = await fetchFromProxy('open-interest-history', { symbol, interval: bybitInterval, startTime: from, endTime: to, limit: 500 });
            const records = data?.records;
            if (!Array.isArray(records) || records.length === 0) {
                throw new Error(`Bybit open interest API did not return data. Response: ${JSON.stringify(data)}`);
            }
            return records.map(entry => {
                const time = normalizeTimestamp(entry.time ?? entry.timestamp);
                if (!time) return null;
                const value = toNumber(entry.openInterest ?? entry.sumOpenInterest ?? entry.value);
                return { time, value };
            }).filter(Boolean).filter(entry => {
                if (!entry) return false;
                if (from && entry.time < from) return false;
                if (to && entry.time > to) return false;
                return true;
            }).sort((a, b) => a.time - b.time);
        }

        async function fetchLiquidations(symbol, interval, from, to) {
            const data = await fetchFromProxy('liquidation-history', { symbol, startTime: from, endTime: to, limit: 500 });
            const records = data?.records;
            if (!Array.isArray(records) || records.length === 0) return [];
            return records.map(entry => {
                const time = normalizeTimestamp(entry.time ?? entry.timestamp);
                if (!time) return null;
                const price = toNumber(entry.price ?? entry.markPrice ?? entry.avgPrice, 1);
                const quantity = toNumber(entry.quantity ?? entry.executedQty ?? entry.origQty);
                const value = toNumber(entry.value ?? price * quantity);
                if (value <= 0) return null;
                const mapped = {
                    time,
                    value,
                    type: resolveLiquidationSide(entry)
                };
                return mapped;
            }).filter(Boolean).filter(entry => {
                if (!entry) return false;
                if (from && entry.time < from) return false;
                if (to && entry.time > to) return false;
                return true;
            }).sort((a, b) => a.time - b.time);
        }


        async function updateChartData() {
            if (isUpdating) return;
            isUpdating = true;
            loader.classList.remove('hidden');
            errorOverlay.classList.add('hidden');
            try {
                const symbol = currentSymbol;

                const to = Math.floor(Date.now() / 1000);
                const intervalSeconds = intervalToSeconds[currentInterval] || 3600;
                const from = to - (500 * intervalSeconds); // Fetch approx 500 candles worth of data

                const results = await Promise.allSettled([
                    fetchKlines(symbol, currentInterval, from, to),
                    fetchOpenInterest(symbol, currentInterval, from, to),
                    fetchLiquidations(symbol, currentInterval, from, to)
                ]);

                const klinesResult = results[0];
                if (klinesResult.status === 'rejected' || !klinesResult.value || klinesResult.value.length === 0) {
                    const reason = klinesResult.reason?.message || 'API returned no klines data.';
                    console.error("Essential klines data could not be fetched.", reason);
                    errorMessageEl.textContent = `No se pudieron obtener los datos (Klines). Razón: ${reason}`;
                    clearAllSeriesData();
                    errorOverlay.classList.remove('hidden');
                    return;
                }

                const klines = klinesResult.value;
                const openInterest = results[1].status === 'fulfilled' ? results[1].value : [];
                const liquidations = results[2].status === 'fulfilled' ? results[2].value : [];

                if (results[1].status === 'rejected') console.warn("Could not fetch Open Interest data:", results[1].reason);
                if (results[2].status === 'rejected') console.warn("Could not fetch Liquidations data:", results[2].reason);

                fetchedData = { klines, openInterest, liquidations };
                renderAllVisuals();

            } catch (error) {
                console.error("An unexpected error occurred during the data update process:", error);
                errorMessageEl.textContent = `Error inesperado: ${error.message}`;
                errorOverlay.classList.remove('hidden');
            } finally {
                loader.classList.add('hidden');
                isUpdating = false;
            }
        }

        function renderAllVisuals() {
            if (!chart || !candlestickSeries) return;
            const { klines, openInterest, liquidations } = fetchedData;

            if (!klines || klines.length === 0) {
                clearAllSeriesData();
                return;
            }

            const volumeData = klines.map(k => ({ time: k.time, value: k.volume, color: themes[currentTheme].volume(k.close, k.open) }));
            const longLiqsData = klines.map(k => ({ time: k.time, value: 0 }));
            const shortLiqsData = klines.map(k => ({ time: k.time, value: 0 }));

            if (liquidations.length > 0) {
                const klineMap = new Map(klines.map((k, i) => [k.time, i]));
                liquidations.forEach(liq => {
                    const kline = klines.find((k, index) => {
                        const nextKlineTime = klines[index + 1] ? klines[index + 1].time : Infinity;
                        return liq.time >= k.time && liq.time < nextKlineTime;
                    });
                    if (kline) {
                        const index = klineMap.get(kline.time);
                        if (index !== undefined) {
                            if (liq.type === 'long') longLiqsData[index].value += liq.value;
                            else shortLiqsData[index].value += liq.value;
                        }
                    }
                });
            }

            fetchedData.longLiqs = longLiqsData;
            fetchedData.shortLiqs = shortLiqsData;

            const oiMap = new Map(openInterest.map(oi => [oi.time, oi.value]));
            const oiVolRatioData = klines.map(kline => {
                const oiValue = oiMap.get(kline.time);
                if (oiValue && kline.volume > 0) {
                    const volumeInUSD = kline.volume * kline.close;
                    return { time: kline.time, value: oiValue / volumeInUSD };
                }
                return { time: kline.time, value: 0 };
            });
            fetchedData.oiVolRatioData = oiVolRatioData;

            runWithTimeScaleLock(() => {
                candlestickSeries.setData(klines);
                volumeSeries.setData(volumeData);
                openInterestSeries.setData(openInterest);
                longLiqsSeries.setData(longLiqsData);
                shortLiqsSeries.setData(shortLiqsData);
                oiVolRatioSeries.setData(oiVolRatioData);
                drawAllLiquidationZones(klines, selectedLeverages, oiVolRatioData);
            });

            maybeAutoFitTimeScale();
            updateLiquidityPanel();
        }

        function drawAllLiquidationZones(klines, leverages, oiVolRatioData) {
            clearAllZones();
            if (klines.length < 2) return;
            calculateAndDrawActiveZones(klines, leverages, oiVolRatioData);
            findAndDrawHistoricalZones(klines, fetchedData.longLiqs, fetchedData.shortLiqs);
            drawOverlayClusters();
        }

        function updateLiquidityPanel() {
            if (!liquidityZonesContainer) return;

            const allZones = [];

            // Agregar zonas activas (futuras)
            latestHeatmapClusters.long.forEach(cluster => {
                allZones.push({
                    price: cluster.price,
                    centerPrice: cluster.centerPrice,
                    value: cluster.totalValue,
                    side: 'long',
                    type: 'active'
                });
            });

            latestHeatmapClusters.short.forEach(cluster => {
                allZones.push({
                    price: cluster.price,
                    centerPrice: cluster.centerPrice,
                    value: cluster.totalValue,
                    side: 'short',
                    type: 'active'
                });
            });

            // Agregar zonas históricas
            historicalLiquidityZones.forEach(zone => {
                allZones.push({
                    price: (zone.high + zone.low) / 2,
                    centerPrice: (zone.high + zone.low) / 2,
                    value: zone.totalValue,
                    side: zone.side,
                    type: 'historical',
                    high: zone.high,
                    low: zone.low
                });
            });

            // Ordenar por valor descendente
            allZones.sort((a, b) => b.value - a.value);

            // Limitar a 15 zonas para no saturar
            const displayZones = allZones.slice(0, 15);

            // Renderizar zonas
            liquidityZonesContainer.innerHTML = displayZones.map(zone => {
                const priceStr = zone.price.toFixed(2);
                const valueStr = formatLiquidityValue(zone.value);
                const typeLabel = zone.type === 'active' ? '●' : '○';
                const isLong = zone.side === 'long';
                const bgColor = zone.type === 'active'
                    ? (isLong ? 'rgba(34, 197, 94, 0.15)' : 'rgba(239, 68, 68, 0.15)')
                    : 'rgba(56, 189, 248, 0.08)';

                return `
                    <div class="liquidity-zone-item ${zone.side}" style="background-color: ${bgColor};">
                        <div class="zone-price">${typeLabel} ${priceStr}</div>
                        <div class="zone-value">${valueStr}</div>
                        <div class="zone-strength" style="background-color: ${isLong ? 'rgba(34, 197, 94, 0.25)' : 'rgba(239, 68, 68, 0.25)'};">
                            ${(zone.value / Math.max(...displayZones.map(z => z.value)) * 100).toFixed(0)}%
                        </div>
                    </div>
                `;
            }).join('');
        }

        // ==================== CLUSTER TRACKING SYSTEM ====================

        // Initialize IndexedDB for cluster tracking
        async function initClusterTrackingDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('ClusterTrackingDB', 1);

                request.onerror = () => {
                    console.error('❌ Failed to open IndexedDB:', request.error);
                    trackingEnabled = false;
                    reject(request.error);
                };

                request.onsuccess = () => {
                    clusterTrackingDB = request.result;
                    console.log('✅ Cluster tracking database initialized');
                    resolve(clusterTrackingDB);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    if (!db.objectStoreNames.contains('clusters')) {
                        const objectStore = db.createObjectStore('clusters', { keyPath: 'id' });

                        // Create indexes for efficient querying
                        objectStore.createIndex('symbol', 'symbol', { unique: false });
                        objectStore.createIndex('side', 'side', { unique: false });
                        objectStore.createIndex('touchedAt', 'touchedAt', { unique: false });
                        objectStore.createIndex('outcome', 'outcome.type', { unique: false });
                        objectStore.createIndex('createdAt', 'createdAt', { unique: false });

                        console.log('📊 Cluster tracking object store created');
                    }
                };
            });
        }

        // Save cluster to tracking database
        async function saveClusterToTracking(cluster) {
            if (!trackingEnabled || !clusterTrackingDB) return;

            try {
                const transaction = clusterTrackingDB.transaction(['clusters'], 'readwrite');
                const objectStore = transaction.objectStore('clusters');

                const record = {
                    id: cluster.id,
                    symbol: currentSymbol,
                    interval: currentInterval,
                    side: cluster.side,
                    priceLevel: cluster.centerPrice || cluster.price,
                    priceRange: {
                        min: cluster.minPrice,
                        max: cluster.maxPrice
                    },
                    intensity: normalizeIntensity(cluster.totalValue || 0),
                    totalValue: cluster.totalValue || 0,
                    createdAt: cluster.createdAt,
                    touchedAt: cluster.touchedAt || null,
                    outcome: cluster.outcome || null
                };

                objectStore.put(record);  // Use put to update if exists

                return new Promise((resolve, reject) => {
                    transaction.oncomplete = () => resolve(record);
                    transaction.onerror = () => reject(transaction.error);
                });
            } catch (error) {
                console.error('❌ Error saving cluster:', error);
            }
        }

        // Check if price has touched any clusters
        function checkClusterTouches() {
            if (!trackingEnabled || !candlestickSeries) return;

            const klines = fetchedData.klines;
            if (!klines || klines.length === 0) return;

            const currentPrice = klines[klines.length - 1].close;
            const currentTime = Date.now();

            // Check active clusters
            const allClusters = [
                ...latestHeatmapClusters.long,
                ...latestHeatmapClusters.short,
                ...historicalHeatmapClusters.long,
                ...historicalHeatmapClusters.short
            ];

            allClusters.forEach(cluster => {
                // Assign ID if not exists
                if (!cluster.id) {
                    cluster.id = `cluster_${currentSymbol}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    cluster.createdAt = currentTime;
                    cluster.tracked = true;

                    // Save initial cluster
                    saveClusterToTracking(cluster);
                }

                // Check if price touched cluster
                if (!cluster.touched && currentPrice >= cluster.minPrice && currentPrice <= cluster.maxPrice) {
                    cluster.touched = true;
                    cluster.touchedAt = currentTime;
                    cluster.touchPrice = currentPrice;

                    console.log(`🎯 Cluster touched! ${cluster.side} at $${currentPrice.toFixed(2)}`);

                    // Update cluster in database
                    saveClusterToTracking(cluster);

                    // Start monitoring for outcome
                    monitorClusterOutcome(cluster);
                }
            });
        }

        // Monitor cluster outcome after touch
        function monitorClusterOutcome(cluster) {
            const OBSERVATION_PERIOD = 3600000; // 1 hour
            const CHECK_INTERVAL = 60000; // 1 minute
            const priceHistory = [];

            const monitoringInterval = setInterval(() => {
                const klines = fetchedData.klines;
                if (!klines || klines.length === 0) {
                    clearInterval(monitoringInterval);
                    return;
                }

                const currentPrice = klines[klines.length - 1].close;
                const currentTime = Date.now();

                priceHistory.push({
                    time: currentTime,
                    price: currentPrice
                });

                // Stop monitoring after observation period
                if (currentTime - cluster.touchedAt >= OBSERVATION_PERIOD) {
                    clearInterval(monitoringInterval);

                    // Determine outcome
                    const outcome = determineClusterOutcome(cluster, priceHistory);
                    cluster.outcome = outcome;

                    console.log(`📈 Cluster outcome: ${outcome.type} (${outcome.bouncePercent?.toFixed(2)}%)`);

                    // Save final outcome
                    saveClusterToTracking(cluster);
                }
            }, CHECK_INTERVAL);
        }

        // Determine cluster outcome based on price history
        function determineClusterOutcome(cluster, priceHistory) {
            if (priceHistory.length === 0) {
                return { type: 'unknown', bouncePercent: 0 };
            }

            const touchPrice = cluster.touchPrice;

            // Calculate max bounce in the expected direction
            const maxBounce = Math.max(...priceHistory.map(p => {
                if (cluster.side === 'long') {
                    // Long cluster: expect bounce UP
                    return (p.price - touchPrice) / touchPrice * 100;
                } else {
                    // Short cluster: expect bounce DOWN
                    return (touchPrice - p.price) / touchPrice * 100;
                }
            }));

            // Classify outcome
            if (maxBounce >= 1.5) {
                return {
                    type: 'strong_bounce',
                    bouncePercent: maxBounce,
                    duration: priceHistory[priceHistory.length - 1].time - priceHistory[0].time
                };
            } else if (maxBounce >= 0.5) {
                return {
                    type: 'weak_bounce',
                    bouncePercent: maxBounce
                };
            } else if (maxBounce < 0) {
                return {
                    type: 'breakthrough',
                    penetrationPercent: Math.abs(maxBounce)
                };
            } else {
                return {
                    type: 'no_reaction',
                    bouncePercent: maxBounce
                };
            }
        }

        // ==================== ANALYTICS FUNCTIONS ====================

        // Get all clusters from database
        async function getAllClusters() {
            if (!clusterTrackingDB) return [];

            return new Promise((resolve, reject) => {
                const transaction = clusterTrackingDB.transaction(['clusters'], 'readonly');
                const objectStore = transaction.objectStore('clusters');
                const request = objectStore.getAll();

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Calculate analytics metrics
        async function calculateAnalytics() {
            const allClusters = await getAllClusters();

            if (allClusters.length === 0) {
                return {
                    total: 0,
                    touched: 0,
                    touchRate: 0,
                    strongBounce: 0,
                    weakBounce: 0,
                    breakthrough: 0,
                    noReaction: 0,
                    bounceRate: 0,
                    avgBounce: 0,
                    bySymbol: {},
                    bySide: { long: {}, short: {} },
                    byIntensity: {}
                };
            }

            const touched = allClusters.filter(c => c.touchedAt);
            const withOutcome = allClusters.filter(c => c.outcome);

            const strongBounce = withOutcome.filter(c => c.outcome.type === 'strong_bounce');
            const weakBounce = withOutcome.filter(c => c.outcome.type === 'weak_bounce');
            const breakthrough = withOutcome.filter(c => c.outcome.type === 'breakthrough');
            const noReaction = withOutcome.filter(c => c.outcome.type === 'no_reaction');

            const bounces = [...strongBounce, ...weakBounce];
            const avgBounce = bounces.length > 0
                ? bounces.reduce((sum, c) => sum + (c.outcome.bouncePercent || 0), 0) / bounces.length
                : 0;

            // Performance by side
            const longClusters = touched.filter(c => c.side === 'long');
            const shortClusters = touched.filter(c => c.side === 'short');

            const longBounces = longClusters.filter(c =>
                c.outcome?.type === 'strong_bounce' || c.outcome?.type === 'weak_bounce'
            );
            const shortBounces = shortClusters.filter(c =>
                c.outcome?.type === 'strong_bounce' || c.outcome?.type === 'weak_bounce'
            );

            // Performance by intensity
            const highIntensity = touched.filter(c => c.intensity >= 0.7);
            const medIntensity = touched.filter(c => c.intensity >= 0.4 && c.intensity < 0.7);
            const lowIntensity = touched.filter(c => c.intensity < 0.4);

            return {
                total: allClusters.length,
                touched: touched.length,
                touchRate: (touched.length / allClusters.length * 100).toFixed(1),
                strongBounce: strongBounce.length,
                weakBounce: weakBounce.length,
                breakthrough: breakthrough.length,
                noReaction: noReaction.length,
                bounceRate: touched.length > 0
                    ? (bounces.length / touched.length * 100).toFixed(1)
                    : 0,
                avgBounce: avgBounce.toFixed(2),
                bySide: {
                    long: {
                        total: longClusters.length,
                        bounces: longBounces.length,
                        bounceRate: longClusters.length > 0
                            ? (longBounces.length / longClusters.length * 100).toFixed(1)
                            : 0
                    },
                    short: {
                        total: shortClusters.length,
                        bounces: shortBounces.length,
                        bounceRate: shortClusters.length > 0
                            ? (shortBounces.length / shortClusters.length * 100).toFixed(1)
                            : 0
                    }
                },
                byIntensity: {
                    high: {
                        total: highIntensity.length,
                        bounceRate: highIntensity.length > 0
                            ? (highIntensity.filter(c => c.outcome?.type?.includes('bounce')).length / highIntensity.length * 100).toFixed(1)
                            : 0
                    },
                    medium: {
                        total: medIntensity.length,
                        bounceRate: medIntensity.length > 0
                            ? (medIntensity.filter(c => c.outcome?.type?.includes('bounce')).length / medIntensity.length * 100).toFixed(1)
                            : 0
                    },
                    low: {
                        total: lowIntensity.length,
                        bounceRate: lowIntensity.length > 0
                            ? (lowIntensity.filter(c => c.outcome?.type?.includes('bounce')).length / lowIntensity.length * 100).toFixed(1)
                            : 0
                    }
                }
            };
        }

        // Update analytics UI
        async function updateAnalyticsUI() {
            const stats = await calculateAnalytics();

            // Update DOM elements
            document.getElementById('total-tracked').textContent = stats.total;
            document.getElementById('total-touched').textContent = `${stats.touched} (${stats.touchRate}%)`;
            document.getElementById('strong-bounce').textContent = `${stats.strongBounce} (${stats.strongBounce > 0 ? (stats.strongBounce / stats.touched * 100).toFixed(1) : 0}%)`;
            document.getElementById('weak-bounce').textContent = `${stats.weakBounce} (${stats.weakBounce > 0 ? (stats.weakBounce / stats.touched * 100).toFixed(1) : 0}%)`;
            document.getElementById('breakthrough').textContent = `${stats.breakthrough} (${stats.breakthrough > 0 ? (stats.breakthrough / stats.touched * 100).toFixed(1) : 0}%)`;
            document.getElementById('bounce-rate').textContent = `${stats.bounceRate}%`;
            document.getElementById('avg-bounce').textContent = `${stats.avgBounce}%`;

            // Update side performance
            document.getElementById('long-performance').textContent = `${stats.bySide.long.bounceRate}% (${stats.bySide.long.bounces}/${stats.bySide.long.total})`;
            document.getElementById('short-performance').textContent = `${stats.bySide.short.bounceRate}% (${stats.bySide.short.bounces}/${stats.bySide.short.total})`;

            // Update intensity performance
            document.getElementById('high-intensity').textContent = `${stats.byIntensity.high.bounceRate}% (${stats.byIntensity.high.total})`;
            document.getElementById('med-intensity').textContent = `${stats.byIntensity.medium.bounceRate}% (${stats.byIntensity.medium.total})`;
            document.getElementById('low-intensity').textContent = `${stats.byIntensity.low.bounceRate}% (${stats.byIntensity.low.total})`;
        }

        // Export analytics to CSV
        async function exportAnalytics() {
            const allClusters = await getAllClusters();

            if (allClusters.length === 0) {
                alert('No hay datos para exportar');
                return;
            }

            const csv = [
                ['ID', 'Symbol', 'Interval', 'Side', 'Price', 'Intensity', 'Created', 'Touched', 'Time to Touch (h)', 'Outcome', 'Bounce %'].join(','),
                ...allClusters.map(c => [
                    c.id,
                    c.symbol,
                    c.interval,
                    c.side,
                    c.priceLevel.toFixed(2),
                    c.intensity.toFixed(2),
                    new Date(c.createdAt).toISOString(),
                    c.touchedAt ? new Date(c.touchedAt).toISOString() : 'N/A',
                    c.touchedAt ? ((c.touchedAt - c.createdAt) / 3600000).toFixed(2) : 'N/A',
                    c.outcome?.type || 'pending',
                    c.outcome?.bouncePercent?.toFixed(2) || 'N/A'
                ].join(','))
            ].join('\n');

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `cluster-analytics-${currentSymbol}-${Date.now()}.csv`;
            link.click();
            URL.revokeObjectURL(url);

            console.log(`📥 Exported ${allClusters.length} clusters to CSV`);
        }

        function clearAllZones() {
            historicalPriceLines.forEach(line => candlestickSeries.removePriceLine(line));
            activePriceLines.forEach(line => candlestickSeries.removePriceLine(line));
            historicalPriceLines = [];
            activePriceLines = [];
            historicalLiquidityZones = [];
            heatmapLongSeries.forEach(series => series.setData([]));
            heatmapShortSeries.forEach(series => series.setData([]));
            latestHeatmapClusters = { long: [], short: [] };
            historicalHeatmapClusters = { long: [], short: [] };
            updateLiquidityPanel();
            drawOverlayClusters();
        }

        function calculateAndDrawActiveZones(klines, leverages, oiVolRatioData) {
            const liquidationPools = new Map();
            const relevantKlines = klines.slice(-100);
            const lastKline = klines[klines.length - 1];
            const priceStep = lastKline.close * 0.0002;

            const blurKernel = [
                { offset: -2, weight: 0.1 }, { offset: -1, weight: 0.2 },
                { offset: 0, weight: 0.4 },
                { offset: 1, weight: 0.2 }, { offset: 2, weight: 0.1 },
            ];

            leverages.forEach(leverage => {
                relevantKlines.forEach(kline => {
                    const entryPrice = (kline.high + kline.low) / 2;
                    const positionVolume = kline.volume / (2 * leverages.length);

                    const processLiquidation = (price, volume) => {
                        const basePoolKey = Math.round(price / priceStep);
                        blurKernel.forEach(k => {
                            const finalKey = (basePoolKey + k.offset) * priceStep;
                            const volToAdd = volume * k.weight;
                            if (!liquidationPools.has(finalKey)) liquidationPools.set(finalKey, { volume: 0 });
                            liquidationPools.get(finalKey).volume += volToAdd;
                        });
                    };

                    processLiquidation(entryPrice * (1 - 1 / leverage), positionVolume);
                    processLiquidation(entryPrice * (1 + 1 / leverage), positionVolume);
                });
            });

            const lastPrice = lastKline.close;
            let poolsArray = Array.from(liquidationPools.entries()).map(([price, data]) => ({ price, ...data }));

            const maxLiquidity = Math.max(...poolsArray.map(p => p.volume * p.price), 0);
            maxLiquidityObserved = maxLiquidity;
            updateLiquiditySliderLabel();
            const thresholdValue = maxLiquidityObserved * liquidityThresholdPct;
            const filteredPools = poolsArray.filter(p => (p.volume * p.price) >= thresholdValue);

            const clusterSpan = Math.max(priceStep * 4, (lastKline.high - lastKline.low) * 0.4 || priceStep);
            const bandHalfHeight = Math.max(priceStep * 1.5, clusterSpan * 0.35);
            const lastCandleTime = lastKline.time;
            const intervalSeconds = klines.length > 1 ? klines[1].time - klines[0].time : 3600;
            const futureTime = lastCandleTime + intervalSeconds * FUTURE_BARS_PROJECTION;

            const buildClusters = (pools, side) => {
                if (!pools.length) return [];
                const map = new Map();
                pools.forEach(pool => {
                    const clusterKey = Math.round(pool.price / clusterSpan);
                    let cluster = map.get(clusterKey);
                    if (!cluster) {
                        cluster = {
                            minPrice: pool.price,
                            maxPrice: pool.price,
                            volume: 0,
                            totalValue: 0
                        };
                        map.set(clusterKey, cluster);
                    }
                    cluster.minPrice = Math.min(cluster.minPrice, pool.price);
                    cluster.maxPrice = Math.max(cluster.maxPrice, pool.price);
                    cluster.volume += pool.volume;
                    cluster.totalValue += pool.volume * pool.price;
                });
                return Array.from(map.values())
                    .map(cluster => {
                        const centerPrice = (cluster.minPrice + cluster.maxPrice) / 2;
                        return {
                            ...cluster,
                            price: centerPrice,
                            centerPrice,
                            side
                        };
                    })
                    .sort((a, b) => b.totalValue - a.totalValue)
                    .slice(0, 50);
            };

            const longClusters = buildClusters(filteredPools.filter(p => p.price < lastPrice), 'long');
            const shortClusters = buildClusters(filteredPools.filter(p => p.price > lastPrice), 'short');

            const maxLongVol = longClusters.length ? Math.max(...longClusters.map(c => c.volume)) : 1;
            const maxShortVol = shortClusters.length ? Math.max(...shortClusters.map(c => c.volume)) : 1;

            const drawHeatmap = (pools, seriesArray, maxVolume, type) => {
                const cappedPools = pools.slice(0, HEATMAP_SERIES_COUNT);

                cappedPools.forEach((pool, i) => {
                    const intensity = Math.min(1, pool.volume / maxVolume);
                    const isLong = type === 'long';

                    const color = isLong
                        ? `rgba(34, 197, 94, ${0.12 + intensity * 0.55})`
                        : `rgba(239, 68, 68, ${0.12 + intensity * 0.55})`;
                    const lineWidth = 1 + intensity * 3;

                    const series = seriesArray[i];
                    series.applyOptions({ color, lineWidth });
                    series.setData([{ time: lastCandleTime, value: pool.price }, { time: futureTime, value: pool.price }]);

                    if (i < VISIBLE_LABELS_COUNT) {
                        const liquidityInUSD = pool.totalValue;
                        const title = formatLiquidityValue(liquidityInUSD);

                        const labelLine = candlestickSeries.createPriceLine({
                            price: pool.price,
                            color: 'transparent',
                            axisLabelVisible: true,
                            title: title,
                            axisLabelColor: isLong ? '#14b8a6' : '#f87171',
                            axisLabelTextColor: '#f8fafc',
                        });
                        activePriceLines.push(labelLine);
                    }
                });

                const usedSeries = Math.min(cappedPools.length, seriesArray.length);
                for (let i = usedSeries; i < seriesArray.length; i++) {
                    seriesArray[i].setData([]);
                }
            };

            const longClustersWithTime = longClusters.map(cluster => ({
                ...cluster,
                startTime: lastCandleTime,
                endTime: futureTime
            }));
            const shortClustersWithTime = shortClusters.map(cluster => ({
                ...cluster,
                startTime: lastCandleTime,
                endTime: futureTime
            }));

            drawHeatmap(longClustersWithTime, heatmapLongSeries, maxLongVol, 'long');
            drawHeatmap(shortClustersWithTime, heatmapShortSeries, maxShortVol, 'short');

            latestHeatmapClusters = {
                long: longClustersWithTime.slice(0, 25),
                short: shortClustersWithTime.slice(0, 25)
            };

            // Calculate historical clusters from past candles
            historicalHeatmapClusters = calculateHistoricalClusters(klines, leverages);
        }

        function calculateHistoricalClusters(klines, leverages) {
            const allHistoricalClusters = { long: [], short: [] };
            const currentPrice = klines[klines.length - 1].close;
            const currentTime = Math.floor(Date.now() / 1000);

            // Process last 100 candles (excluding the last one which is in latestHeatmapClusters)
            const lookbackCandles = Math.min(100, klines.length - 1);
            const startIndex = Math.max(0, klines.length - lookbackCandles - 1);

            for (let candleIndex = startIndex; candleIndex < klines.length - 1; candleIndex++) {
                const kline = klines[candleIndex];
                const liquidationPools = new Map();
                const priceStep = kline.close * 0.0002;

                const blurKernel = [
                    { offset: -2, weight: 0.1 }, { offset: -1, weight: 0.2 },
                    { offset: 0, weight: 0.4 },
                    { offset: 1, weight: 0.2 }, { offset: 2, weight: 0.1 },
                ];

                // Calculate liquidation levels for this candle
                leverages.forEach(leverage => {
                    const entryPrice = (kline.high + kline.low) / 2;
                    const positionVolume = kline.volume / (2 * leverages.length);

                    const processLiquidation = (price, volume) => {
                        const basePoolKey = Math.round(price / priceStep);
                        blurKernel.forEach(k => {
                            const finalKey = (basePoolKey + k.offset) * priceStep;
                            const volToAdd = volume * k.weight;
                            if (!liquidationPools.has(finalKey)) liquidationPools.set(finalKey, { volume: 0 });
                            liquidationPools.get(finalKey).volume += volToAdd;
                        });
                    };

                    processLiquidation(entryPrice * (1 - 1 / leverage), positionVolume);
                    processLiquidation(entryPrice * (1 + 1 / leverage), positionVolume);
                });

                // Build clusters for this candle
                let poolsArray = Array.from(liquidationPools.entries()).map(([price, data]) => ({ price, ...data }));
                const clusterSpan = Math.max(priceStep * 4, (kline.high - kline.low) * 0.4 || priceStep);

                const buildClusters = (pools, side) => {
                    if (!pools.length) return [];
                    const map = new Map();
                    pools.forEach(pool => {
                        const clusterKey = Math.round(pool.price / clusterSpan);
                        let cluster = map.get(clusterKey);
                        if (!cluster) {
                            cluster = {
                                minPrice: pool.price,
                                maxPrice: pool.price,
                                volume: 0,
                                totalValue: 0
                            };
                            map.set(clusterKey, cluster);
                        }
                        cluster.minPrice = Math.min(cluster.minPrice, pool.price);
                        cluster.maxPrice = Math.max(cluster.maxPrice, pool.price);
                        cluster.volume += pool.volume;
                        cluster.totalValue += pool.volume * pool.price;
                    });
                    return Array.from(map.values())
                        .map(cluster => {
                            const centerPrice = (cluster.minPrice + cluster.maxPrice) / 2;
                            return {
                                ...cluster,
                                price: centerPrice,
                                centerPrice,
                                side,
                                candleIndex
                            };
                        });
                };

                const longPools = poolsArray.filter(p => p.price < kline.close);
                const shortPools = poolsArray.filter(p => p.price > kline.close);

                const longClusters = buildClusters(longPools, 'long');
                const shortClusters = buildClusters(shortPools, 'short');

                // Filter out consumed clusters
                const isClusterConsumed = (cluster) => {
                    const clusterHigh = cluster.maxPrice;
                    const clusterLow = cluster.minPrice;

                    // Check all candles AFTER this cluster was created
                    for (let i = candleIndex + 1; i < klines.length; i++) {
                        const futureKline = klines[i];
                        // If price crossed through the cluster range
                        if (futureKline.low <= clusterHigh && futureKline.high >= clusterLow) {
                            return true;
                        }
                    }
                    return false;
                };

                // Add unconsumed clusters with time information
                const intervalSeconds = klines.length > 1 ? klines[1].time - klines[0].time : 3600;
                const extendedEndTime = currentTime + (30 * 24 * 60 * 60);

                longClusters.forEach(cluster => {
                    if (!isClusterConsumed(cluster)) {
                        allHistoricalClusters.long.push({
                            ...cluster,
                            startTime: kline.time,
                            endTime: extendedEndTime
                        });
                    }
                });

                shortClusters.forEach(cluster => {
                    if (!isClusterConsumed(cluster)) {
                        allHistoricalClusters.short.push({
                            ...cluster,
                            startTime: kline.time,
                            endTime: extendedEndTime
                        });
                    }
                });
            }

            // Limit to top 50 clusters per side
            const topLongs = allHistoricalClusters.long
                .sort((a, b) => b.totalValue - a.totalValue)
                .slice(0, 50);

            const topShorts = allHistoricalClusters.short
                .sort((a, b) => b.totalValue - a.totalValue)
                .slice(0, 50);

            console.log(`✅ Calculated ${topLongs.length} historical long clusters + ${topShorts.length} historical short clusters`);

            return { long: topLongs, short: topShorts };
        }

        function findAndDrawHistoricalZones(klines, longLiqs, shortLiqs) {
            const totalLiqs = klines.map((k, i) => ({
                kline: k,
                index: i,
                totalLiqValue: (longLiqs[i]?.value || 0) + (shortLiqs[i]?.value || 0)
            }));

            const significantLiqs = totalLiqs
                .filter(l => l.totalLiqValue > 0)
                .sort((a, b) => b.totalLiqValue - a.totalLiqValue);

            if (significantLiqs.length === 0) return;

            const avgLiqValue = significantLiqs.reduce((sum, l) => sum + l.totalLiqValue, 0) / significantLiqs.length;
            const liqThreshold = avgLiqValue * 0.2;  // Reduced from 0.5 to 0.2 to show more zones

            const MAX_HISTORICAL_ZONES = 50;  // Increased from 20 to 50
            let zonesDrawn = 0;

            for (const liq of significantLiqs) {
                if (zonesDrawn >= MAX_HISTORICAL_ZONES) break;
                if (liq.totalLiqValue < liqThreshold) continue;

                const drawLine = (price, isTop) => {
                    const line = candlestickSeries.createPriceLine({
                        price: price,
                        color: '#808080',
                        lineWidth: 1,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        axisLabelVisible: isTop,
                        title: isTop ? `$${(liq.totalLiqValue / 1e6).toFixed(1)}M` : '',
                        axisLabelColor: '#808080',
                        axisLabelTextColor: '#ffffff',
                    });
                    historicalPriceLines.push(line);
                };

                const longValue = longLiqs[liq.index]?.value || 0;
                const shortValue = shortLiqs[liq.index]?.value || 0;
                const dominantSide = longValue >= shortValue ? 'long' : 'short';

                // Extend zone duration to current time + 30 days to keep them visible
                const currentTime = Math.floor(Date.now() / 1000);
                const nextKlineTime = klines[liq.index + 1]?.time ?? (klines.length > 1 ? liq.kline.time + (klines[1].time - klines[0].time) : liq.kline.time + 3600);
                const extendedEndTime = Math.max(nextKlineTime, currentTime + (30 * 24 * 60 * 60));  // Extend 30 days

                drawLine(liq.kline.high, true);
                drawLine(liq.kline.low, false);

                const zone = {
                    startTime: liq.kline.time,
                    endTime: extendedEndTime,
                    high: liq.kline.high,
                    low: liq.kline.low,
                    totalValue: liq.totalLiqValue,
                    side: dominantSide
                };

                historicalLiquidityZones.push(zone);

                // Debug logging
                if (zonesDrawn < 3) {  // Log first 3 zones
                    console.log(`Historical Zone ${zonesDrawn}:`, {
                        price: `${zone.low.toFixed(2)}-${zone.high.toFixed(2)}`,
                        side: zone.side,
                        value: `$${(zone.totalValue / 1e6).toFixed(2)}M`,
                        startTime: new Date(zone.startTime * 1000).toISOString(),
                        endTime: new Date(zone.endTime * 1000).toISOString()
                    });
                }

                zonesDrawn++;
            }

            // Summary log
            console.log(`✅ Created ${historicalLiquidityZones.length} historical liquidation zones`);
        }

        function clearAllSeriesData() {
            if (!candlestickSeries) return;
            candlestickSeries.setData([]);
            volumeSeries.setData([]);
            openInterestSeries.setData([]);
            longLiqsSeries.setData([]);
            shortLiqsSeries.setData([]);
            oiVolRatioSeries.setData([]);
            clearAllZones();
        }

        function handleResize() {
            if (chart) {
                runWithTimeScaleLock(() => chart.resize(chartContainer.clientWidth, chartContainer.clientHeight));
            }
            resizeHeatmapOverlay();
            drawOverlayClusters();
        }

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeChart();
            applyTheme(currentTheme);
            updateLiquiditySliderLabel();
            updateChartData();
            chartContainer.addEventListener('dblclick', () => {
                resetUserTimeScalePreference();
                maybeAutoFitTimeScale();
            });

            // Toggle Liquidity Panel
            togglePanelBtn.addEventListener('click', () => {
                liquidityPanel.classList.toggle('active');
            });

            setInterval(() => {
                if (!isUpdating) {
                    updateChartData();
                }
            }, 30000);

            // Drawing Tool Logic
            drawLineTool.addEventListener('click', () => {
                isDrawingMode = !isDrawingMode;
                drawLineTool.classList.toggle('active', isDrawingMode);
            });

            chart.subscribeClick(param => {
                if (!isDrawingMode || !param.point) return;

                const price = candlestickSeries.coordinateToPrice(param.point.y);

                const lineToRemove = userDrawnLines.find(line => {
                    const linePrice = line.options().price;
                    const lineCoordinate = candlestickSeries.priceToCoordinate(linePrice);
                    if (lineCoordinate === null || lineCoordinate === undefined) return false;
                    return Math.abs(lineCoordinate - param.point.y) < 5;
                });

                if (lineToRemove) {
                    candlestickSeries.removePriceLine(lineToRemove);
                    userDrawnLines = userDrawnLines.filter(l => l !== lineToRemove);
                } else {
                    const newLine = candlestickSeries.createPriceLine({
                        price: price,
                        color: '#2962FF',
                        lineWidth: 2,
                        lineStyle: LightweightCharts.LineStyle.Solid,
                        axisLabelVisible: true,
                        title: ''
                    });
                    userDrawnLines.push(newLine);
                }
            });

            themeToggle.addEventListener('click', () => {
                currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
                applyTheme(currentTheme);
            });

            symbolSelector.addEventListener('change', (e) => {
                currentSymbol = e.target.value;
                resetUserTimeScalePreference();
                updateChartData();
            });

            intervalButtonsContainer.addEventListener('click', (e) => {
                const target = e.target.closest('.interval-btn');
                if (!target) return;
                intervalButtonsContainer.querySelector('.active').classList.remove('active');
                target.classList.add('active');
                currentInterval = target.dataset.interval;
                resetUserTimeScalePreference();
                updateChartData();
            });

            leverageButtonsContainer.addEventListener('click', (e) => {
                const target = e.target.closest('.leverage-btn');
                if (!target) return;
                target.classList.toggle('active');

                selectedLeverages = Array.from(leverageButtonsContainer.querySelectorAll('.active'))
                    .map(btn => parseInt(btn.dataset.leverage, 10));

                if (selectedLeverages.length === 0) {
                    target.classList.add('active');
                    selectedLeverages.push(parseInt(target.dataset.leverage, 10));
                }
                renderAllVisuals();
            });

            liquiditySlider.addEventListener('input', (e) => {
                liquidityThresholdPct = Number(e.target.value) / 100;
                updateLiquiditySliderLabel();
                renderAllVisuals();
            });

            window.addEventListener('resize', handleResize);

            // Initialize cluster tracking database
            initClusterTrackingDB().catch(err => {
                console.warn('⚠️ Cluster tracking disabled:', err);
            });
            ```

            const significantLiqs = totalLiqs
                .filter(l => l.totalLiqValue > 0)
                .sort((a, b) => b.totalLiqValue - a.totalLiqValue);

            if (significantLiqs.length === 0) return;

            const avgLiqValue = significantLiqs.reduce((sum, l) => sum + l.totalLiqValue, 0) / significantLiqs.length;
            const liqThreshold = avgLiqValue * 0.2;  // Reduced from 0.5 to 0.2 to show more zones

            const MAX_HISTORICAL_ZONES = 50;  // Increased from 20 to 50
            let zonesDrawn = 0;

            for (const liq of significantLiqs) {
                if (zonesDrawn >= MAX_HISTORICAL_ZONES) break;
                if (liq.totalLiqValue < liqThreshold) continue;

                const drawLine = (price, isTop) => {
                    const line = candlestickSeries.createPriceLine({
                        price: price,
                        color: '#808080',
                        lineWidth: 1,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        axisLabelVisible: isTop,
                        title: isTop ? `$${ (liq.totalLiqValue / 1e6).toFixed(1) } M` : '',
                        axisLabelColor: '#808080',
                        axisLabelTextColor: '#ffffff',
                    });
                    historicalPriceLines.push(line);
                };

                const longValue = longLiqs[liq.index]?.value || 0;
                const shortValue = shortLiqs[liq.index]?.value || 0;
                const dominantSide = longValue >= shortValue ? 'long' : 'short';

                // Extend zone duration to current time + 30 days to keep them visible
                const currentTime = Math.floor(Date.now() / 1000);
                const nextKlineTime = klines[liq.index + 1]?.time ?? (klines.length > 1 ? liq.kline.time + (klines[1].time - klines[0].time) : liq.kline.time + 3600);
                const extendedEndTime = Math.max(nextKlineTime, currentTime + (30 * 24 * 60 * 60));  // Extend 30 days

                drawLine(liq.kline.high, true);
                drawLine(liq.kline.low, false);

                const zone = {
                    startTime: liq.kline.time,
                    endTime: extendedEndTime,
                    high: liq.kline.high,
                    low: liq.kline.low,
                    totalValue: liq.totalLiqValue,
                    side: dominantSide
                };

                historicalLiquidityZones.push(zone);

                // Debug logging
                if (zonesDrawn < 3) {  // Log first 3 zones
                    console.log(`Historical Zone ${ zonesDrawn }: `, {
                        price: `${ zone.low.toFixed(2) } -${ zone.high.toFixed(2) } `,
                        side: zone.side,
                        value: `$${ (zone.totalValue / 1e6).toFixed(2) } M`,
                        startTime: new Date(zone.startTime * 1000).toISOString(),
                        endTime: new Date(zone.endTime * 1000).toISOString()
                    });
                }

                zonesDrawn++;
            }

            // Summary log
            console.log(`✅ Created ${ historicalLiquidityZones.length } historical liquidation zones`);
        }

        function clearAllSeriesData() {
            if (!candlestickSeries) return;
            candlestickSeries.setData([]);
            volumeSeries.setData([]);
            openInterestSeries.setData([]);
            longLiqsSeries.setData([]);
            shortLiqsSeries.setData([]);
            oiVolRatioSeries.setData([]);
            clearAllZones();
        }

        function handleResize() {
            if (chart) {
                runWithTimeScaleLock(() => chart.resize(chartContainer.clientWidth, chartContainer.clientHeight));
            }
            resizeHeatmapOverlay();
            drawOverlayClusters();
        }

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeChart();
            applyTheme(currentTheme);
            updateLiquiditySliderLabel();
            updateChartData();
            chartContainer.addEventListener('dblclick', () => {
                resetUserTimeScalePreference();
                maybeAutoFitTimeScale();
            });

            // Toggle Liquidity Panel
            togglePanelBtn.addEventListener('click', () => {
                liquidityPanel.classList.toggle('active');
            });

            setInterval(() => {
                if (!isUpdating) {
                    updateChartData();
                }
            }, 30000);

            // Drawing Tool Logic
            drawLineTool.addEventListener('click', () => {
                isDrawingMode = !isDrawingMode;
                drawLineTool.classList.toggle('active', isDrawingMode);
            });

            chart.subscribeClick(param => {
                if (!isDrawingMode || !param.point) return;

                const price = candlestickSeries.coordinateToPrice(param.point.y);

                const lineToRemove = userDrawnLines.find(line => {
                    const linePrice = line.options().price;
                    const lineCoordinate = candlestickSeries.priceToCoordinate(linePrice);
                    if (lineCoordinate === null || lineCoordinate === undefined) return false;
                    return Math.abs(lineCoordinate - param.point.y) < 5;
                });

                if (lineToRemove) {
                    candlestickSeries.removePriceLine(lineToRemove);
                    userDrawnLines = userDrawnLines.filter(l => l !== lineToRemove);
                } else {
                    const newLine = candlestickSeries.createPriceLine({
                        price: price,
                        color: '#2962FF',
                        lineWidth: 2,
                        lineStyle: LightweightCharts.LineStyle.Solid,
                        axisLabelVisible: true,
                        title: ''
                    });
                    userDrawnLines.push(newLine);
                }
            });

            themeToggle.addEventListener('click', () => {
                currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
                applyTheme(currentTheme);
            });

            symbolSelector.addEventListener('change', (e) => {
                currentSymbol = e.target.value;
                resetUserTimeScalePreference();
                updateChartData();
            });

            intervalButtonsContainer.addEventListener('click', (e) => {
                const target = e.target.closest('.interval-btn');
                if (!target) return;
                intervalButtonsContainer.querySelector('.active').classList.remove('active');
                target.classList.add('active');
                currentInterval = target.dataset.interval;
                resetUserTimeScalePreference();
                updateChartData();
            });

            leverageButtonsContainer.addEventListener('click', (e) => {
                const target = e.target.closest('.leverage-btn');
                if (!target) return;
                target.classList.toggle('active');

                selectedLeverages = Array.from(leverageButtonsContainer.querySelectorAll('.active'))
                    .map(btn => parseInt(btn.dataset.leverage, 10));

                if (selectedLeverages.length === 0) {
                    target.classList.add('active');
                    selectedLeverages.push(parseInt(target.dataset.leverage, 10));
                }
                renderAllVisuals();
            });

            liquiditySlider.addEventListener('input', (e) => {
                liquidityThresholdPct = Number(e.target.value) / 100;
                updateLiquiditySliderLabel();
                renderAllVisuals();
            });

            window.addEventListener('resize', handleResize);

            // Initialize cluster tracking database
            initClusterTrackingDB().catch(err => {
                console.warn('⚠️ Cluster tracking disabled:', err);
            });

            // Check cluster touches periodically (every 5 seconds)
            setInterval(() => {
                checkClusterTouches();
            }, 5000);
            
            // Update analytics UI periodically (every 10 seconds)
            setInterval(() => {
                updateAnalyticsUI();
            }, 10000);
            
            // Initial analytics update
            setTimeout(() => {
                updateAnalyticsUI();
            }, 2000);
            
            console.log('🚀 Liquidation Zone Heatmap initialized with cluster tracking');
        });
    </script>
</body>

</html>