<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Liquidation Heatmap</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lightweight Charts library by TradingView (pinned to a stable version) -->
    <script src="https://unpkg.com/lightweight-charts@4.0.1/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #131722;
            color: #d1d4dc;
        }
        /* Custom scrollbar for a better look */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1e222d;
        }
        ::-webkit-scrollbar-thumb {
            background: #4a4e59;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #5a5e69;
        }
        .control-button {
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        .control-button.active {
            background-color: #2962FF;
            color: #fff;
        }
        .indicator-label {
            position: absolute;
            left: 12px;
            color: rgba(209, 212, 220, 0.7);
            font-size: 12px;
            font-weight: bold;
            pointer-events: none; /* Allows clicking through the label */
            z-index: 10;
        }
    </style>
</head>
<body class="flex flex-col h-screen antialiased">

    <!-- Header with controls -->
    <header class="p-4 bg-[#1e222d] border-b border-gray-700 shadow-md">
        <div class="container mx-auto flex flex-col gap-4">
            <div class="flex flex-wrap items-center justify-between gap-4">
                <div class="flex-grow">
                    <h1 class="text-2xl font-bold text-white">Liquidation Zone Heatmap</h1>
                     <div id="legend" class="text-xs text-gray-400 flex items-center gap-4 mt-1 flex-wrap">
                        <span>Leyenda:</span>
                        <span class="flex items-center"><div class="w-3 h-0.5 bg-red-500 mr-1"></div> Zonas Activas (Shorts)</span>
                        <span class="flex items-center"><div class="w-3 h-0.5 bg-green-500 mr-1"></div> Zonas Activas (Longs)</span>
                        <span class="flex items-center"><div class="w-3 h-0 border-t-2 border-dashed border-gray-500 mr-1"></div> Liquidaciones Pasadas</span>
                         <span class="flex items-center text-yellow-400">⭐ Más Probable</span>
                    </div>
                </div>
                <div id="controls" class="flex flex-wrap items-center gap-4">
                    <!-- Symbol Selection -->
                    <select id="symbol" class="bg-[#2a2e39] text-white border border-gray-600 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="BTCUSDT" selected>BTC/USDT</option>
                        <option value="ETHUSDT">ETH/USDT</option>
                        <option value="BNBUSDT">BNB/USDT</option>
                        <option value="SOLUSDT">SOL/USDT</option>
                        <option value="XRPUSDT">XRP/USDT</option>
                        <option value="WLDUSDT">WLD/USDT</option>
                    </select>
                    <!-- Interval Selection -->
                    <div id="interval-buttons" class="flex items-center bg-[#2a2e39] border border-gray-600 rounded-lg p-1">
                        <button class="interval-btn control-button px-3 py-1 rounded-md text-sm font-medium" data-interval="1m">1m</button>
                        <button class="interval-btn control-button px-3 py-1 rounded-md text-sm font-medium" data-interval="5m">5m</button>
                        <button class="interval-btn control-button px-3 py-1 rounded-md text-sm font-medium" data-interval="15m">15m</button>
                        <button class="interval-btn control-button px-3 py-1 rounded-md text-sm font-medium" data-interval="1h">1H</button>
                        <button class="interval-btn control-button px-3 py-1 rounded-md text-sm font-medium active" data-interval="4h">4H</button>
                        <button class="interval-btn control-button px-3 py-1 rounded-md text-sm font-medium" data-interval="1d">1D</button>
                    </div>
                     <!-- Leverage Selection -->
                    <div id="leverage-buttons" class="flex items-center bg-[#2a2e39] border border-gray-600 rounded-lg p-1">
                        <button class="leverage-btn control-button px-2 py-1 rounded-md text-sm font-medium" data-leverage="5">5x</button>
                        <button class="leverage-btn control-button px-2 py-1 rounded-md text-sm font-medium" data-leverage="10">10x</button>
                        <button class="leverage-btn control-button px-2 py-1 rounded-md text-sm font-medium" data-leverage="25">25x</button>
                        <button class="leverage-btn control-button px-2 py-1 rounded-md text-sm font-medium active" data-leverage="50">50x</button>
                        <button class="leverage-btn control-button px-2 py-1 rounded-md text-sm font-medium" data-leverage="100">100x</button>
                    </div>
                    <div id="loader" class="hidden w-6 h-6 border-4 border-blue-500 border-t-transparent border-solid rounded-full animate-spin"></div>
                </div>
            </div>
            <!-- Liquidity Concentration Slider -->
            <div id="liquidity-slider-container" class="flex items-center gap-3 text-sm text-gray-400 pt-2">
                <label for="liquidity-slider" class="whitespace-nowrap">Concentración de Liquidez:</label>
                <input type="range" id="liquidity-slider" min="0" max="100" value="0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                <span id="slider-value" class="font-mono text-white bg-gray-700 px-2 py-1 rounded-md">$0M</span>
            </div>
        </div>
    </header>

    <!-- Chart Container -->
    <main class="flex-grow relative">
        <div id="chart-container" class="absolute top-0 left-0 w-full h-full">
            <!-- Indicator Labels -->
            <div id="indicator-labels" class="absolute top-0 left-0 w-full h-full pointer-events-none">
                <div class="indicator-label" style="top: 61%;">Volumen</div>
                <div class="indicator-label" style="top: 71%;">Interés Abierto (OI)</div>
                <div class="indicator-label" style="top: 81%;">Liquidaciones</div>
                <div class="indicator-label" style="top: 91%;">Ratio OI/VOL</div>
            </div>
        </div>
    </main>

    <script>
        // --- DOM Elements ---
        const chartContainer = document.getElementById('chart-container');
        const symbolSelector = document.getElementById('symbol');
        const intervalButtonsContainer = document.getElementById('interval-buttons');
        const leverageButtonsContainer = document.getElementById('leverage-buttons');
        const liquiditySlider = document.getElementById('liquidity-slider');
        const sliderValueEl = document.getElementById('slider-value');
        const loader = document.getElementById('loader');

        // --- Chart State ---
        let chart;
        let candlestickSeries, volumeSeries, openInterestSeries, longLiqsSeries, shortLiqsSeries, oiVolRatioSeries;
        let activeLongSeries = [], activeShortSeries = [];
        let historicalPriceLines = [], activePriceLines = [];
        let socket = null;
        let fetchedData = { klines: [], openInterest: [], liquidations: [] };
        const MAX_ACTIVE_ZONES = 10;

        let currentSymbol = 'BTCUSDT';
        let currentInterval = '4h';
        let selectedLeverages = [50];
        let liquidityThreshold = 0;

        function initializeChart() {
             chart = LightweightCharts.createChart(chartContainer, {
                width: chartContainer.clientWidth, height: chartContainer.clientHeight,
                layout: { backgroundColor: '#131722', textColor: '#d1d4dc' },
                grid: { vertLines: { color: 'rgba(42, 46, 57, 0.8)' }, horzLines: { color: 'rgba(42, 46, 57, 0.8)' } },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                timeScale: { borderColor: '#485c7b', timeVisible: true, secondsVisible: false },
            });

            candlestickSeries = chart.addCandlestickSeries({ upColor: '#26a69a', downColor: '#ef5350', borderDownColor: '#ef5350', borderUpColor: '#26a69a', wickDownColor: '#ef5350', wickUpColor: '#26a69a', priceScaleId: 'right' });
            
            const mainPaneHeight = 0.6;
            const indicatorPaneHeight = (1 - mainPaneHeight) / 4;

            volumeSeries = chart.addHistogramSeries({ priceFormat: { type: 'volume' }, priceScaleId: 'volume', scaleMargins: { top: mainPaneHeight, bottom: 1 - (mainPaneHeight + indicatorPaneHeight) } });
            chart.priceScale('volume').applyOptions({ scaleMargins: { top: mainPaneHeight, bottom: 1 - (mainPaneHeight + indicatorPaneHeight) } });

            openInterestSeries = chart.addLineSeries({ color: '#2962FF', lineWidth: 2, priceScaleId: 'oi', scaleMargins: { top: mainPaneHeight + indicatorPaneHeight, bottom: 1 - (mainPaneHeight + 2 * indicatorPaneHeight) } });
            chart.priceScale('oi').applyOptions({ scaleMargins: { top: mainPaneHeight + indicatorPaneHeight, bottom: 1 - (mainPaneHeight + 2 * indicatorPaneHeight) } });
            
            longLiqsSeries = chart.addHistogramSeries({ color: 'rgba(239, 83, 80, 0.7)', priceFormat: { type: 'volume' }, priceScaleId: 'liquidations', scaleMargins: { top: mainPaneHeight + 2 * indicatorPaneHeight, bottom: 1 - (mainPaneHeight + 3 * indicatorPaneHeight) } });
            shortLiqsSeries = chart.addHistogramSeries({ color: 'rgba(38, 166, 154, 0.7)', priceFormat: { type: 'volume' }, priceScaleId: 'liquidations', scaleMargins: { top: mainPaneHeight + 2 * indicatorPaneHeight, bottom: 1 - (mainPaneHeight + 3 * indicatorPaneHeight) } });
            chart.priceScale('liquidations').applyOptions({ scaleMargins: { top: mainPaneHeight + 2 * indicatorPaneHeight, bottom: 1 - (mainPaneHeight + 3 * indicatorPaneHeight) } });

            oiVolRatioSeries = chart.addLineSeries({ color: '#facc15', lineWidth: 2, priceScaleId: 'oi_vol_ratio', scaleMargins: { top: mainPaneHeight + 3 * indicatorPaneHeight, bottom: 0 } });
            chart.priceScale('oi_vol_ratio').applyOptions({ scaleMargins: { top: mainPaneHeight + 3 * indicatorPaneHeight, bottom: 0 } });

            for (let i = 0; i < MAX_ACTIVE_ZONES; i++) {
                activeLongSeries.push(chart.addLineSeries({ priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false, priceScaleId: 'right' }));
                activeShortSeries.push(chart.addLineSeries({ priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false, priceScaleId: 'right' }));
            }
        }
        
        const apiIntervalMap = { '1m':'5m', '5m':'5m', '15m':'15m', '1h':'1h', '4h':'4h', '1d':'1d' };
        
        async function robustFetch(fetchFunction) {
            try {
                return await fetchFunction();
            } catch (error) {
                console.warn(`A data fetch operation failed: ${error.message}`);
                return []; // Return an empty array to prevent breaking the app
            }
        }

        async function fetchKlines(symbol, interval) {
            // CORRECTED: Using fapi.binance.com for futures candlestick data
            const response = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol.toUpperCase()}&interval=${interval}&limit=500`);
            if (!response.ok) throw new Error(`API Error fetching klines: ${response.statusText}`);
            const data = await response.json();
            if (!Array.isArray(data)) throw new Error('Klines API did not return an array.');
            return data.map(d => ({
                time: d[0] / 1000, open: parseFloat(d[1]), high: parseFloat(d[2]),
                low: parseFloat(d[3]), close: parseFloat(d[4]), volume: parseFloat(d[5])
            }));
        }

        async function fetchOpenInterest(symbol, interval) {
            const apiInterval = apiIntervalMap[interval] || '4h';
            const response = await fetch(`https://fapi.binance.com/futures/data/openInterestHist?symbol=${symbol}&period=${apiInterval}&limit=500`);
            if (!response.ok) throw new Error(`Open Interest API Error: ${response.statusText}`);
            const data = await response.json();
             if (!Array.isArray(data)) throw new Error('Open Interest API did not return an array.');
            return data.map(d => ({
                time: parseInt(d.timestamp) / 1000,
                value: parseFloat(d.sumOpenInterestValue)
            }));
        }

        async function fetchLiquidations(symbol) {
            const response = await fetch(`https://fapi.binance.com/fapi/v1/allForceOrders?symbol=${symbol.toUpperCase()}&limit=500`);
            if (!response.ok) throw new Error(`Liquidations API Error: ${response.statusText}`);
            const data = await response.json();
            if (!Array.isArray(data)) {
                console.warn(`Liquidations API for ${symbol} did not return an array, got:`, data);
                return [];
            }
            return data.map(d => ({
                time: d.time / 1000,
                value: parseFloat(d.executedQty) * parseFloat(d.price),
                type: d.side === 'SELL' ? 'long' : 'short'
            }));
        }

        function setupWebSocket() {
            if (socket) {
                socket.close();
            }
            socket = new WebSocket(`wss://fstream.binance.com/ws/${currentSymbol.toLowerCase()}@kline_${currentInterval}`);
            socket.onmessage = (event) => {
                const message = JSON.parse(event.data);
                const kline = message.k;
                if (kline.x) {
                    updateChartData();
                } else {
                    candlestickSeries.update({
                        time: kline.t / 1000,
                        open: parseFloat(kline.o), high: parseFloat(kline.h),
                        low: parseFloat(kline.l), close: parseFloat(kline.c)
                    });
                }
            };
        }

        async function updateChartData() {
            loader.classList.remove('hidden');
            try {
                // Use Promise.allSettled to handle individual API call failures gracefully
                const results = await Promise.allSettled([
                    fetchKlines(currentSymbol, currentInterval),
                    fetchOpenInterest(currentSymbol, currentInterval),
                    fetchLiquidations(currentSymbol)
                ]);

                const klinesResult = results[0];
                const openInterestResult = results[1];
                const liquidationsResult = results[2];

                // Klines data is essential. If it fails, we cannot render the chart.
                if (klinesResult.status === 'rejected' || !klinesResult.value || klinesResult.value.length === 0) {
                    console.error("Essential klines data could not be fetched.", klinesResult.reason || 'API returned no klines data.');
                    clearAllSeriesData();
                    return;
                }

                // For other data sources, we can proceed even if they fail, using an empty array as a fallback.
                const klines = klinesResult.value;
                const openInterest = openInterestResult.status === 'fulfilled' ? openInterestResult.value : [];
                const liquidations = liquidationsResult.status === 'fulfilled' ? liquidationsResult.value : [];

                if (openInterestResult.status === 'rejected') {
                    console.warn("Could not fetch Open Interest data:", openInterestResult.reason);
                }
                if (liquidationsResult.status === 'rejected') {
                    console.warn("Could not fetch Liquidations data:", liquidationsResult.reason);
                }

                fetchedData = { klines, openInterest, liquidations };
                renderAllVisuals();
                
            } catch (error) {
                console.error("An unexpected error occurred during the data update process:", error);
            } finally {
                loader.classList.add('hidden');
            }
        }
        
        function renderAllVisuals() {
            const { klines, openInterest, liquidations } = fetchedData;
            
            if (!klines || klines.length === 0) {
                clearAllSeriesData();
                // This console error is now handled in updateChartData
                return;
            }
            
            const volumeData = klines.map(k => ({ time: k.time, value: k.volume, color: k.close >= k.open ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)' }));
            const longLiqsData = klines.map(k => ({ time: k.time, value: 0 }));
            const shortLiqsData = klines.map(k => ({ time: k.time, value: 0 }));
            
            if (liquidations.length > 0) {
                const klineMap = new Map(klines.map((k, i) => [k.time, i]));
                liquidations.forEach(liq => {
                    const kline = klines.find((k, index) => {
                        const nextKlineTime = klines[index + 1] ? klines[index + 1].time : Infinity;
                        return liq.time >= k.time && liq.time < nextKlineTime;
                    });
                    if (kline) {
                        const index = klineMap.get(kline.time);
                        if (index !== undefined) {
                            if (liq.type === 'long') longLiqsData[index].value += liq.value;
                            else shortLiqsData[index].value += liq.value;
                        }
                    }
                });
            }

            const oiMap = new Map(openInterest.map(oi => [oi.time, oi.value]));
            const oiVolRatioData = klines.map(kline => {
                const oiValue = oiMap.get(kline.time);
                if (oiValue && kline.volume > 0) {
                        const volumeInUSD = kline.volume * kline.close;
                    return { time: kline.time, value: oiValue / volumeInUSD };
                }
                return { time: kline.time, value: 0 };
            });

            candlestickSeries.setData(klines);
            volumeSeries.setData(volumeData);
            openInterestSeries.setData(openInterest);
            longLiqsSeries.setData(longLiqsData);
            shortLiqsSeries.setData(shortLiqsData);
            oiVolRatioSeries.setData(oiVolRatioData);

            drawAllLiquidationZones(klines, selectedLeverages, oiVolRatioData);
            chart.timeScale().fitContent();
            
            setupWebSocket();
        }

        function drawAllLiquidationZones(klines, leverages, oiVolRatioData) {
            clearAllZones();
            if (klines.length < 2) return;
            calculateAndDrawActiveZones(klines, leverages, oiVolRatioData);
            findAndDrawHistoricalZones(klines);
        }

        function clearAllZones() {
            historicalPriceLines.forEach(line => candlestickSeries.removePriceLine(line));
            activePriceLines.forEach(line => candlestickSeries.removePriceLine(line));
            historicalPriceLines = [];
            activePriceLines = [];
            activeLongSeries.forEach(series => series.setData([]));
            activeShortSeries.forEach(series => series.setData([]));
        }

        function calculateProbabilityScore(pool, lastKline, klines, allPools, oiVolRatioData) {
            const proximityScore = 1 / (Math.abs(pool.price - lastKline.close) / lastKline.close);
            const maxVol = Math.max(...allPools.map(p => p.volume), 1);
            const sizeScore = pool.volume / maxVol;

            const recentKlines = klines.slice(-3);
            const priceChange = recentKlines[2].close - recentKlines[0].open;
            let momentumScore = 0.5;
            if (pool.price > lastKline.close && priceChange > 0) momentumScore = 1;
            if (pool.price < lastKline.close && priceChange < 0) momentumScore = 1;

            const atrPeriod = 14;
            const ranges = klines.slice(-atrPeriod).map(k => k.high - k.low);
            const atr = ranges.reduce((a, b) => a + b, 0) / ranges.length;
            const currentRange = lastKline.high - lastKline.low;
            const volatilityScore = currentRange > atr * 1.5 ? 1 : 0.5;

            let oiVolScore = 0.5;
            if ((currentInterval === '1h' || currentInterval === '4h') && oiVolRatioData.length > 0) {
                const recentRatios = oiVolRatioData.slice(-5).map(d => d.value).filter(v => v > 0);
                if (recentRatios.length > 2) {
                    const avgFirstHalf = recentRatios.slice(0, Math.floor(recentRatios.length / 2)).reduce((a, b) => a + b, 0) / Math.floor(recentRatios.length / 2);
                    const avgSecondHalf = recentRatios.slice(Math.floor(recentRatios.length / 2)).reduce((a, b) => a + b, 0) / Math.ceil(recentRatios.length / 2);
                    if (avgSecondHalf > avgFirstHalf * 1.05) {
                        oiVolScore = 1;
                    }
                }
            }

            return (proximityScore * 0.35) + (sizeScore * 0.25) + (momentumScore * 0.15) + (volatilityScore * 0.1) + (oiVolScore * 0.15);
        }

        function calculateAndDrawActiveZones(klines, leverages, oiVolRatioData) {
            const liquidationPools = new Map();
            const relevantKlines = klines.slice(-100);
            const lastKline = klines[klines.length - 1];
            const priceStep = lastKline.close * 0.0005;

            leverages.forEach(leverage => {
                relevantKlines.forEach(kline => {
                    const entryPrice = (kline.high + kline.low) / 2;
                    const positionVolume = kline.volume / (2 * leverages.length);
                    const longLiqPrice = entryPrice * (1 - 1 / leverage);
                    const shortLiqPrice = entryPrice * (1 + 1 / leverage);
                    const longPoolKey = Math.round(longLiqPrice / priceStep) * priceStep;
                    const shortPoolKey = Math.round(shortLiqPrice / priceStep) * priceStep;
                    
                    if (!liquidationPools.has(longPoolKey)) liquidationPools.set(longPoolKey, { volume: 0, startTime: kline.time });
                    liquidationPools.get(longPoolKey).volume += positionVolume;

                    if (!liquidationPools.has(shortPoolKey)) liquidationPools.set(shortPoolKey, { volume: 0, startTime: kline.time });
                    liquidationPools.get(shortPoolKey).volume += positionVolume;
                });
            });

            const lastPrice = lastKline.close;
            let poolsArray = Array.from(liquidationPools.entries()).map(([price, data]) => ({ price, ...data }));
            
            const maxLiquidity = Math.max(...poolsArray.map(p => p.volume * p.price), 0);
            liquiditySlider.max = maxLiquidity;
            const filteredPools = poolsArray.filter(p => (p.volume * p.price) >= liquidityThreshold);
            
            let highestScore = -1;
            let mostProbablePool = null;
            filteredPools.forEach(pool => {
                pool.score = calculateProbabilityScore(pool, lastKline, klines, filteredPools, oiVolRatioData);
                if (pool.score > highestScore) {
                    highestScore = pool.score;
                    mostProbablePool = pool;
                }
            });

            const longPools = filteredPools.filter(p => p.price < lastPrice && p.volume > 0).sort((a,b) => b.volume - a.volume);
            const shortPools = filteredPools.filter(p => p.price > lastPrice && p.volume > 0).sort((a,b) => b.volume - a.volume);
            const maxLongVol = longPools[0]?.volume || 1;
            const maxShortVol = shortPools[0]?.volume || 1;
            const lastTime = klines[klines.length - 1].time;
            const intervalSeconds = klines.length > 1 ? klines[1].time - klines[0].time : 3600;
            const futureTime = lastTime + intervalSeconds * 50;

            const updateSeriesAndLabels = (pools, seriesArray, maxVolume, type) => {
                pools.slice(0, MAX_ACTIVE_ZONES).forEach((pool, i) => {
                    const intensity = Math.min(1, pool.volume / maxVolume);
                    const isLong = type === 'long';
                    const color = isLong ? `rgba(38, 166, 154, ${0.2 + intensity * 0.7})` : `rgba(239, 83, 80, ${0.2 + intensity * 0.7})`;
                    const lineWidth = 1 + Math.floor(intensity * 4);
                    
                    const series = seriesArray[i];
                    series.applyOptions({ color, lineWidth });
                    series.setData([{ time: pool.startTime, value: pool.price }, { time: futureTime, value: pool.price }]);

                    const liquidityInUSD = pool.volume * pool.price;
                    let title = `$${(liquidityInUSD / 1e6).toFixed(1)}M`;
                    if (mostProbablePool && mostProbablePool.price === pool.price) {
                         title = `⭐ ${title} (Más Probable)`;
                    }
                    
                    const labelLine = candlestickSeries.createPriceLine({
                        price: pool.price,
                        color: 'transparent',
                        axisLabelVisible: true,
                        title: title,
                        axisLabelColor: (mostProbablePool && mostProbablePool.price === pool.price) ? '#facc15' : (isLong ? '#26a69a' : '#ef5350'),
                        axisLabelTextColor: '#ffffff',
                    });
                    activePriceLines.push(labelLine);
                });
            };

            updateSeriesAndLabels(longPools, activeLongSeries, maxLongVol, 'long');
            updateSeriesAndLabels(shortPools, activeShortSeries, maxShortVol, 'short');
        }

        function findAndDrawHistoricalZones(klines) {
            const volumes = klines.map(k => k.volume);
            const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
            const volumeThreshold = avgVolume * 2.5;

            klines.forEach(kline => {
                const bodySize = Math.abs(kline.open - kline.close);
                const range = kline.high - kline.low;

                if (kline.volume > volumeThreshold && range > bodySize * 3 && bodySize > 0) {
                    const wickSizeTop = kline.high - Math.max(kline.open, kline.close);
                    const wickSizeBottom = Math.min(kline.open, kline.close) - kline.low;
                    
                    const drawHistoricalLine = (price) => {
                         const line = candlestickSeries.createPriceLine({
                            price: price, color: '#6b7280', lineWidth: 2,
                            lineStyle: LightweightCharts.LineStyle.Dotted,
                            axisLabelVisible: true, title: 'Pasado',
                        });
                        historicalPriceLines.push(line);
                    };

                    if (wickSizeTop > range * 0.6) drawHistoricalLine(kline.high);
                    if (wickSizeBottom > range * 0.6) drawHistoricalLine(kline.low);
                }
            });
        }
        
        function clearAllSeriesData() {
            candlestickSeries.setData([]);
            volumeSeries.setData([]);
            openInterestSeries.setData([]);
            longLiqsSeries.setData([]);
            shortLiqsSeries.setData([]);
            oiVolRatioSeries.setData([]);
            clearAllZones();
        }
        
        function handleResize() { if (chart) chart.resize(chartContainer.clientWidth, chartContainer.clientHeight); }
        
        // --- Event Listeners ---
        symbolSelector.addEventListener('change', (e) => {
            currentSymbol = e.target.value;
            updateChartData();
        });

        intervalButtonsContainer.addEventListener('click', (e) => {
            const target = e.target.closest('.interval-btn');
            if (!target) return;
            intervalButtonsContainer.querySelector('.active').classList.remove('active');
            target.classList.add('active');
            currentInterval = target.dataset.interval;
            updateChartData();
        });
        
        leverageButtonsContainer.addEventListener('click', (e) => {
            const target = e.target.closest('.leverage-btn');
            if (!target) return;
            target.classList.toggle('active');

            selectedLeverages = Array.from(leverageButtonsContainer.querySelectorAll('.active'))
                                   .map(btn => parseInt(btn.dataset.leverage, 10));

            if (selectedLeverages.length === 0) {
                target.classList.add('active');
                selectedLeverages.push(parseInt(target.dataset.leverage, 10));
            }
            renderAllVisuals();
        });

        liquiditySlider.addEventListener('input', (e) => {
            liquidityThreshold = parseFloat(e.target.value);
            sliderValueEl.textContent = `$${(liquidityThreshold / 1e6).toFixed(1)}M`;
            renderAllVisuals();
        });

        window.addEventListener('resize', handleResize);

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeChart();
            updateChartData();
        });
    </script>
</body>
</html>

