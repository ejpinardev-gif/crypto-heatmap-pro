<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Liquidation Heatmap</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lightweight Charts library by TradingView (pinned to a stable version) -->
    <script src="https://unpkg.com/lightweight-charts@4.0.1/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        :root {
            --background-color: #131722;
            --text-color: #d1d4dc;
            --header-bg-color: #1e222d;
            --control-bg-color: #2a2e39;
            --border-color: #485c7b;
        }

        [data-theme='light'] {
            --background-color: #ffffff;
            --text-color: #131722;
            --header-bg-color: #f8f9fa;
            --control-bg-color: #e9ecef;
            --border-color: #dee2e6;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
        }
        header {
            background-color: var(--header-bg-color);
            border-bottom-color: var(--border-color);
        }
        #controls select, #controls > div, #controls > button {
            background-color: var(--control-bg-color);
            border-color: var(--border-color);
            color: var(--text-color);
        }
        #legend, #liquidity-slider-container label {
            color: #9b9ea3;
        }
        [data-theme='light'] #legend, [data-theme='light'] #liquidity-slider-container label {
            color: #5a5e69;
        }
        #slider-value {
             background-color: #4a4e59;
        }
        [data-theme='light'] #slider-value {
             background-color: #e0e3eb;
             color: #131722;
        }

        /* Custom scrollbar for a better look */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e222d; }
        ::-webkit-scrollbar-thumb { background: #4a4e59; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #5a5e69; }
        [data-theme='light'] ::-webkit-scrollbar-track { background: #f1f1f1; }
        [data-theme='light'] ::-webkit-scrollbar-thumb { background: #adb5bd; }
        [data-theme='light'] ::-webkit-scrollbar-thumb:hover { background: #868e96; }

        .control-button {
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        .control-button.active {
            background-color: #2962FF;
            color: #fff;
        }
        .indicator-label {
            position: absolute;
            left: 12px;
            color: rgba(209, 212, 220, 0.7);
            font-size: 12px;
            font-weight: bold;
            pointer-events: none; /* Allows clicking through the label */
            z-index: 10;
        }
        [data-theme='light'] .indicator-label {
            color: rgba(25, 28, 32, 0.7);
        }
    </style>
</head>
<body class="flex flex-col h-screen antialiased">

    <!-- Header with controls -->
    <header class="p-4 border-b shadow-md">
        <div class="container mx-auto flex flex-col gap-4">
            <div class="flex flex-wrap items-center justify-between gap-4">
                <div class="flex-grow">
                    <h1 class="text-2xl font-bold">Liquidation Zone Heatmap</h1>
                     <div id="legend" class="text-xs flex items-center gap-4 mt-1 flex-wrap">
                        <span>Leyenda:</span>
                        <span class="flex items-center"><div class="w-3 h-0.5 bg-red-500 mr-1"></div> Zonas Activas (Shorts)</span>
                        <span class="flex items-center"><div class="w-3 h-0.5 bg-green-500 mr-1"></div> Zonas Activas (Longs)</span>
                        <span class="flex items-center"><div class="w-3 h-0 border-t-2 border-dashed border-gray-500 mr-1"></div> Liquidaciones Pasadas</span>
                         <span class="flex items-center text-yellow-400">⭐ Más Probable</span>
                    </div>
                </div>
                <div id="controls" class="flex flex-wrap items-center gap-4">
                    <!-- Symbol Selection -->
                    <select id="symbol" class="border rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="BTCUSDT" selected>BTC/USDT</option>
                        <option value="ETHUSDT">ETH/USDT</option>
                        <option value="BNBUSDT">BNB/USDT</option>
                        <option value="SOLUSDT">SOL/USDT</option>
                        <option value="XRPUSDT">XRP/USDT</option>
                        <option value="WLDUSDT">WLD/USDT</option>
                        <option value="COAIUSDT">COAI/USDT</option>
                        <option value="GIGGLEUSDT">GIGGLE/USDT</option>
                    </select>
                    <!-- Interval Selection -->
                    <div id="interval-buttons" class="flex items-center border rounded-lg p-1">
                        <button class="interval-btn control-button px-3 py-1 rounded-md text-sm font-medium" data-interval="1m">1m</button>
                        <button class="interval-btn control-button px-3 py-1 rounded-md text-sm font-medium" data-interval="5m">5m</button>
                        <button class="interval-btn control-button px-3 py-1 rounded-md text-sm font-medium" data-interval="15m">15m</button>
                        <button class="interval-btn control-button px-3 py-1 rounded-md text-sm font-medium" data-interval="1h">1H</button>
                        <button class="interval-btn control-button px-3 py-1 rounded-md text-sm font-medium active" data-interval="4h">4H</button>
                        <button class="interval-btn control-button px-3 py-1 rounded-md text-sm font-medium" data-interval="1d">1D</button>
                    </div>
                     <!-- Leverage Selection -->
                    <div id="leverage-buttons" class="flex items-center border rounded-lg p-1">
                        <button class="leverage-btn control-button px-2 py-1 rounded-md text-sm font-medium" data-leverage="5">5x</button>
                        <button class="leverage-btn control-button px-2 py-1 rounded-md text-sm font-medium" data-leverage="10">10x</button>
                        <button class="leverage-btn control-button px-2 py-1 rounded-md text-sm font-medium" data-leverage="25">25x</button>
                        <button class="leverage-btn control-button px-2 py-1 rounded-md text-sm font-medium active" data-leverage="50">50x</button>
                        <button class="leverage-btn control-button px-2 py-1 rounded-md text-sm font-medium" data-leverage="100">100x</button>
                    </div>
                     <!-- Drawing Tool -->
                    <button id="draw-line-tool" class="control-button p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" title="Dibujar línea horizontal">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M4 8h16M4 16h16" />
                        </svg>
                    </button>
                    <div id="loader" class="hidden w-6 h-6 border-4 border-blue-500 border-t-transparent border-solid rounded-full animate-spin"></div>
                     <!-- Theme Toggle -->
                    <button id="theme-toggle" class="p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <svg id="theme-icon-light" class="h-5 w-5 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                        <svg id="theme-icon-dark" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
                    </button>
                </div>
            </div>
            <!-- Liquidity Concentration Slider -->
            <div id="liquidity-slider-container" class="flex items-center gap-3 text-sm pt-2">
                <label for="liquidity-slider" class="whitespace-nowrap">Concentración de Liquidez:</label>
                <input type="range" id="liquidity-slider" min="0" max="100" value="0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                <span id="slider-value" class="font-mono px-2 py-1 rounded-md">$0M</span>
            </div>
        </div>
    </header>

    <!-- Chart Container -->
    <main class="flex-grow relative">
        <div id="chart-container" class="absolute top-0 left-0 w-full h-full">
            <!-- Error Message Overlay -->
            <div id="error-overlay" class="hidden absolute inset-0 bg-red-900 bg-opacity-75 flex flex-col items-center justify-center text-center p-8 z-20">
                <h3 class="text-2xl font-bold text-red-200">Error de Carga de Datos</h3>
                <p id="error-message" class="text-red-300 mt-2">No se pudieron obtener los datos esenciales del mercado. Esto puede ser un problema temporal con la API. Por favor, intente seleccionar otro par o recargar la página en unos momentos.</p>
            </div>
            <!-- Indicator Labels -->
            <div id="indicator-labels" class="absolute top-0 left-0 w-full h-full pointer-events-none">
                <div class="indicator-label" style="top: 61%;">Volumen</div>
                <div class="indicator-label" style="top: 71%;">Interés Abierto (OI)</div>
                <div class="indicator-label" style="top: 81%;">Liquidaciones</div>
                <div class="indicator-label" style="top: 91%;">Ratio OI/VOL</div>
            </div>
        </div>
    </main>

    <script>
        // --- DOM Elements ---
        const chartContainer = document.getElementById('chart-container');
        const symbolSelector = document.getElementById('symbol');
        const intervalButtonsContainer = document.getElementById('interval-buttons');
        const leverageButtonsContainer = document.getElementById('leverage-buttons');
        const liquiditySlider = document.getElementById('liquidity-slider');
        const sliderValueEl = document.getElementById('slider-value');
        const loader = document.getElementById('loader');
        const themeToggle = document.getElementById('theme-toggle');
        const themeIconLight = document.getElementById('theme-icon-light');
        const themeIconDark = document.getElementById('theme-icon-dark');
        const errorOverlay = document.getElementById('error-overlay');
        const errorMessageEl = document.getElementById('error-message');
        const drawLineTool = document.getElementById('draw-line-tool');

        // --- Chart State ---
        let chart;
        let candlestickSeries, volumeSeries, openInterestSeries, longLiqsSeries, shortLiqsSeries, oiVolRatioSeries;
        let heatmapLongSeries = [], heatmapShortSeries = [];
        let historicalPriceLines = [], activePriceLines = [], userDrawnLines = [];
        let fetchedData = { klines: [], openInterest: [], liquidations: [], longLiqs: [], shortLiqs: [] };
        const HEATMAP_SERIES_COUNT = 150;
        const VISIBLE_LABELS_COUNT = 5;

        let currentSymbol = 'BTCUSDT';
        let currentInterval = '4h';
        let selectedLeverages = [50];
        let liquidityThreshold = 0;
        let isUpdating = false;
        let isDrawingMode = false;

        // --- Theme Options ---
        const themes = {
            dark: {
                chart: { layout: { backgroundColor: '#131722', textColor: '#d1d4dc' }, grid: { vertLines: { visible: false }, horzLines: { visible: false } } },
                candlestick: { upColor: '#26a69a', downColor: '#ef5350', borderDownColor: '#ef5350', borderUpColor: '#26a69a', wickDownColor: '#ef5350', wickUpColor: '#26a69a' },
                volume: (close, open) => close >= open ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)'
            },
            light: {
                chart: { layout: { backgroundColor: '#ffffff', textColor: '#131722' }, grid: { vertLines: { visible: false }, horzLines: { visible: false } } },
                candlestick: { upColor: '#26a69a', downColor: '#ef5350', borderDownColor: '#ef5350', borderUpColor: '#26a69a', wickDownColor: '#ef5350', wickUpColor: '#26a69a' },
                volume: (close, open) => close >= open ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)'
            }
        };
        let currentTheme = 'dark';

        function applyTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            const themeOptions = themes[theme];
            if (chart && candlestickSeries) {
                chart.applyOptions(themeOptions.chart);
                candlestickSeries.applyOptions(themeOptions.candlestick);
                if (fetchedData.klines && fetchedData.klines.length > 0) {
                    const volumeData = fetchedData.klines.map(k => ({ time: k.time, value: k.volume, color: themeOptions.volume(k.close, k.open) }));
                    volumeSeries.setData(volumeData);
                }
            }
            themeIconLight.classList.toggle('hidden', theme === 'dark');
            themeIconDark.classList.toggle('hidden', theme === 'light');
        }

        function initializeChart() {
            chart = LightweightCharts.createChart(chartContainer, {
                width: chartContainer.clientWidth, height: chartContainer.clientHeight,
                layout: { backgroundColor: '#131722', textColor: '#d1d4dc' },
                grid: { vertLines: { visible: false }, horzLines: { visible: false } },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                timeScale: { borderColor: '#485c7b', timeVisible: true, secondsVisible: false },
            });

            candlestickSeries = chart.addCandlestickSeries({ upColor: '#26a69a', downColor: '#ef5350', borderDownColor: '#ef5350', borderUpColor: '#26a69a', wickDownColor: '#ef5350', wickUpColor: '#26a69a', priceScaleId: 'right' });
            
            const mainPaneHeight = 0.6;
            const indicatorPaneHeight = (1 - mainPaneHeight) / 4;

            volumeSeries = chart.addHistogramSeries({ priceFormat: { type: 'volume' }, priceScaleId: 'volume', scaleMargins: { top: mainPaneHeight, bottom: 1 - (mainPaneHeight + indicatorPaneHeight) } });
            chart.priceScale('volume').applyOptions({ scaleMargins: { top: mainPaneHeight, bottom: 1 - (mainPaneHeight + indicatorPaneHeight) } });

            openInterestSeries = chart.addLineSeries({ color: '#2962FF', lineWidth: 2, priceScaleId: 'oi', scaleMargins: { top: mainPaneHeight + indicatorPaneHeight, bottom: 1 - (mainPaneHeight + 2 * indicatorPaneHeight) } });
            chart.priceScale('oi').applyOptions({ scaleMargins: { top: mainPaneHeight + indicatorPaneHeight, bottom: 1 - (mainPaneHeight + 2 * indicatorPaneHeight) } });
            
            longLiqsSeries = chart.addHistogramSeries({ color: 'rgba(239, 83, 80, 0.7)', priceFormat: { type: 'volume' }, priceScaleId: 'liquidations', scaleMargins: { top: mainPaneHeight + 2 * indicatorPaneHeight, bottom: 1 - (mainPaneHeight + 3 * indicatorPaneHeight) } });
            shortLiqsSeries = chart.addHistogramSeries({ color: 'rgba(38, 166, 154, 0.7)', priceFormat: { type: 'volume' }, priceScaleId: 'liquidations', scaleMargins: { top: mainPaneHeight + 2 * indicatorPaneHeight, bottom: 1 - (mainPaneHeight + 3 * indicatorPaneHeight) } });
            chart.priceScale('liquidations').applyOptions({ scaleMargins: { top: mainPaneHeight + 2 * indicatorPaneHeight, bottom: 1 - (mainPaneHeight + 3 * indicatorPaneHeight) } });

            oiVolRatioSeries = chart.addLineSeries({ color: '#facc15', lineWidth: 2, priceScaleId: 'oi_vol_ratio', scaleMargins: { top: mainPaneHeight + 3 * indicatorPaneHeight, bottom: 0 } });
            chart.priceScale('oi_vol_ratio').applyOptions({ scaleMargins: { top: mainPaneHeight + 3 * indicatorPaneHeight, bottom: 0 } });

            for (let i = 0; i < HEATMAP_SERIES_COUNT; i++) {
                const commonOptions = { priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false, priceScaleId: 'right' };
                heatmapLongSeries.push(chart.addLineSeries(commonOptions));
                heatmapShortSeries.push(chart.addLineSeries(commonOptions));
            }
        }
        
        async function fetchFromProxy(endpoint, params) {
            const url = new URL(`/api/coinalyze`, window.location.origin);
            url.searchParams.append('endpoint', endpoint);
            for (const key in params) {
                url.searchParams.append(key, params[key]);
            }
            
            console.log(`Requesting data from proxy: ${url}`);

            const response = await fetch(url);
            const responseBody = await response.text(); // Get response body as text to log it

            if (!response.ok) {
                console.error('Proxy Error Response:', responseBody);
                throw new Error(`Proxy API Error for ${endpoint}: ${response.status} ${response.statusText} - ${responseBody}`);
            }
            
            try {
                const data = JSON.parse(responseBody); // Try to parse as JSON
                console.log(`Data received for ${endpoint}:`, data);
                return data;
            } catch (e) {
                console.error('Failed to parse JSON from proxy:', responseBody);
                throw new Error('Received non-JSON response from server.');
            }
        }

        async function fetchKlines(symbol, interval) {
            const coinalyzeInterval = interval.replace('m', 'T').replace('h', 'H').replace('d', 'D');
            const data = await fetchFromProxy('ohlcv', { symbols: symbol, interval: coinalyzeInterval });
            const symbolData = data[0]?.[symbol];
            if (!Array.isArray(symbolData)) throw new Error(`Coinalyze OHLCV API did not return valid data. Response: ${JSON.stringify(data)}`);
            return symbolData.map(d => ({ time: d.t, open: d.o, high: d.h, low: d.l, close: d.c, volume: d.v }));
        }

        async function fetchOpenInterest(symbol, interval) {
            const coinalyzeInterval = interval.replace('m', 'T').replace('h', 'H').replace('d', 'D');
            const data = await fetchFromProxy('open-interest-history', { symbols: symbol, interval: coinalyzeInterval });
            const symbolData = data[0]?.[symbol];
            if (!Array.isArray(symbolData)) throw new Error(`Coinalyze Open Interest API did not return valid data. Response: ${JSON.stringify(data)}`);
            return symbolData.map(d => ({ time: d.t, value: d.v }));
        }

        async function fetchLiquidations(symbol) {
            const to = Math.floor(Date.now() / 1000);
            const from = to - (24 * 60 * 60); // 24 hours ago
            const data = await fetchFromProxy('liquidation-history', { symbols: symbol, from, to });
            const symbolData = data[0]?.[symbol];
            if (!Array.isArray(symbolData)) return []; // It's okay to have no liquidations
            return symbolData.map(d => ({
                time: d.t,
                value: d.q * d.p,
                type: d.m ? 'short' : 'long'
            }));
        }

        async function updateChartData() {
            if (isUpdating) return;
            isUpdating = true;
            loader.classList.remove('hidden');
            errorOverlay.classList.add('hidden');
            try {
                const coinalyzeSymbol = `${currentSymbol}.PERP_BINANCE`;
                const results = await Promise.allSettled([
                    fetchKlines(coinalyzeSymbol, currentInterval),
                    fetchOpenInterest(coinalyzeSymbol, currentInterval),
                    fetchLiquidations(coinalyzeSymbol)
                ]);

                const klinesResult = results[0];
                if (klinesResult.status === 'rejected' || !klinesResult.value || klinesResult.value.length === 0) {
                    const reason = klinesResult.reason?.message || 'API returned no klines data.';
                    console.error("Essential klines data could not be fetched.", reason);
                    errorMessageEl.textContent = `No se pudieron obtener los datos (Klines). Razón: ${reason}`;
                    clearAllSeriesData();
                    errorOverlay.classList.remove('hidden');
                    return;
                }

                const klines = klinesResult.value;
                const openInterest = results[1].status === 'fulfilled' ? results[1].value : [];
                const liquidations = results[2].status === 'fulfilled' ? results[2].value : [];

                if (results[1].status === 'rejected') console.warn("Could not fetch Open Interest data:", results[1].reason);
                if (results[2].status === 'rejected') console.warn("Could not fetch Liquidations data:", results[2].reason);

                fetchedData = { klines, openInterest, liquidations };
                renderAllVisuals();
                
            } catch (error) {
                console.error("An unexpected error occurred during the data update process:", error);
                errorMessageEl.textContent = `Error inesperado: ${error.message}`;
                errorOverlay.classList.remove('hidden');
            } finally {
                loader.classList.add('hidden');
                isUpdating = false;
            }
        }
        
        function renderAllVisuals() {
            const { klines, openInterest, liquidations } = fetchedData;
            
            if (!klines || klines.length === 0) {
                clearAllSeriesData();
                return;
            }
            
            const volumeData = klines.map(k => ({ time: k.time, value: k.volume, color: themes[currentTheme].volume(k.close, k.open) }));
            const longLiqsData = klines.map(k => ({ time: k.time, value: 0 }));
            const shortLiqsData = klines.map(k => ({ time: k.time, value: 0 }));
            
            if (liquidations.length > 0) {
                const klineMap = new Map(klines.map((k, i) => [k.time, i]));
                liquidations.forEach(liq => {
                    const kline = klines.find((k, index) => {
                        const nextKlineTime = klines[index + 1] ? klines[index + 1].time : Infinity;
                        return liq.time >= k.time && liq.time < nextKlineTime;
                    });
                    if (kline) {
                        const index = klineMap.get(kline.time);
                        if (index !== undefined) {
                            if (liq.type === 'long') longLiqsData[index].value += liq.value;
                            else shortLiqsData[index].value += liq.value;
                        }
                    }
                });
            }

            fetchedData.longLiqs = longLiqsData;
            fetchedData.shortLiqs = shortLiqsData;

            const oiMap = new Map(openInterest.map(oi => [oi.time, oi.value]));
            const oiVolRatioData = klines.map(kline => {
                const oiValue = oiMap.get(kline.time);
                if (oiValue && kline.volume > 0) {
                    const volumeInUSD = kline.volume * kline.close;
                    return { time: kline.time, value: oiValue / volumeInUSD };
                }
                return { time: kline.time, value: 0 };
            });
            fetchedData.oiVolRatioData = oiVolRatioData;

            candlestickSeries.setData(klines);
            volumeSeries.setData(volumeData);
            openInterestSeries.setData(openInterest);
            longLiqsSeries.setData(longLiqsData);
            shortLiqsSeries.setData(shortLiqsData);
            oiVolRatioSeries.setData(oiVolRatioData);

            drawAllLiquidationZones(klines, selectedLeverages, oiVolRatioData);
            chart.timeScale().fitContent();
        }

        function drawAllLiquidationZones(klines, leverages, oiVolRatioData) {
            clearAllZones();
            if (klines.length < 2) return;
            calculateAndDrawActiveZones(klines, leverages, oiVolRatioData);
            findAndDrawHistoricalZones(klines, fetchedData.longLiqs, fetchedData.shortLiqs);
        }

        function clearAllZones() {
            historicalPriceLines.forEach(line => candlestickSeries.removePriceLine(line));
            activePriceLines.forEach(line => candlestickSeries.removePriceLine(line));
            historicalPriceLines = [];
            activePriceLines = [];
            heatmapLongSeries.forEach(series => series.setData([]));
            heatmapShortSeries.forEach(series => series.setData([]));
        }

        function calculateAndDrawActiveZones(klines, leverages, oiVolRatioData) {
            const liquidationPools = new Map();
            const relevantKlines = klines.slice(-100);
            const lastKline = klines[klines.length - 1];
            const priceStep = lastKline.close * 0.0002;

            const blurKernel = [
                { offset: -2, weight: 0.1 }, { offset: -1, weight: 0.2 },
                { offset: 0, weight: 0.4 },
                { offset: 1, weight: 0.2 }, { offset: 2, weight: 0.1 },
            ];

            leverages.forEach(leverage => {
                relevantKlines.forEach(kline => {
                    const entryPrice = (kline.high + kline.low) / 2;
                    const positionVolume = kline.volume / (2 * leverages.length);
                    
                    const processLiquidation = (price, volume) => {
                        const basePoolKey = Math.round(price / priceStep);
                        blurKernel.forEach(k => {
                            const finalKey = (basePoolKey + k.offset) * priceStep;
                            const volToAdd = volume * k.weight;
                            if (!liquidationPools.has(finalKey)) liquidationPools.set(finalKey, { volume: 0 });
                            liquidationPools.get(finalKey).volume += volToAdd;
                        });
                    };

                    processLiquidation(entryPrice * (1 - 1 / leverage), positionVolume);
                    processLiquidation(entryPrice * (1 + 1 / leverage), positionVolume);
                });
            });

            const lastPrice = lastKline.close;
            let poolsArray = Array.from(liquidationPools.entries()).map(([price, data]) => ({ price, ...data }));
            
            const maxLiquidity = Math.max(...poolsArray.map(p => p.volume * p.price), 0);
            liquiditySlider.max = maxLiquidity;
            const filteredPools = poolsArray.filter(p => (p.volume * p.price) >= liquidityThreshold);
            
            const longPools = filteredPools.filter(p => p.price < lastPrice).sort((a,b) => b.volume - a.volume);
            const shortPools = filteredPools.filter(p => p.price > lastPrice).sort((a,b) => b.volume - a.volume);
            
            const maxLongVol = longPools[0]?.volume || 1;
            const maxShortVol = shortPools[0]?.volume || 1;
            
            const lastTime = klines[klines.length - 1].time;
            const intervalSeconds = klines.length > 1 ? klines[1].time - klines[0].time : 3600;
            const futureTime = lastTime + intervalSeconds * 10;

            const drawHeatmap = (pools, seriesArray, maxVolume, type) => {
                const topPools = pools.slice(0, VISIBLE_LABELS_COUNT);
                
                pools.slice(0, HEATMAP_SERIES_COUNT).forEach((pool, i) => {
                    const intensity = Math.min(1, pool.volume / maxVolume);
                    const isLong = type === 'long';
                    
                    const color = isLong ? `rgba(0, 255, 0, ${0.05 + intensity * 0.4})` : `rgba(255, 0, 0, ${0.05 + intensity * 0.4})`;
                    const lineWidth = 0.5 + intensity * 3.5;
                    
                    const series = seriesArray[i];
                    series.applyOptions({ color, lineWidth });
                    series.setData([{ time: lastTime, value: pool.price }, { time: futureTime, value: pool.price }]);

                    if (i < VISIBLE_LABELS_COUNT && pool.price === topPools[i].price) {
                        const liquidityInUSD = pool.volume * pool.price;
                        const title = `$${(liquidityInUSD / 1e6).toFixed(1)}M`;
                        
                        const labelLine = candlestickSeries.createPriceLine({
                            price: pool.price,
                            color: 'transparent',
                            axisLabelVisible: true,
                            title: title,
                            axisLabelColor: isLong ? '#26a69a' : '#ef5350',
                            axisLabelTextColor: '#ffffff',
                        });
                        activePriceLines.push(labelLine);
                    }
                });
            };

            drawHeatmap(longPools, heatmapLongSeries, maxLongVol, 'long');
            drawHeatmap(shortPools, heatmapShortSeries, maxShortVol, 'short');
        }

        function findAndDrawHistoricalZones(klines, longLiqs, shortLiqs) {
            const totalLiqs = klines.map((k, i) => ({
                kline: k,
                totalLiqValue: (longLiqs[i]?.value || 0) + (shortLiqs[i]?.value || 0)
            }));

            const significantLiqs = totalLiqs
                .filter(l => l.totalLiqValue > 0)
                .sort((a, b) => b.totalLiqValue - a.totalLiqValue);

            if (significantLiqs.length === 0) return;

            const avgLiqValue = significantLiqs.reduce((sum, l) => sum + l.totalLiqValue, 0) / significantLiqs.length;
            const liqThreshold = avgLiqValue * 2.0;

            const MAX_HISTORICAL_ZONES = 7;
            let zonesDrawn = 0;

            for (const liq of significantLiqs) {
                if (zonesDrawn >= MAX_HISTORICAL_ZONES) break;
                if (liq.totalLiqValue < liqThreshold) continue;

                const drawLine = (price, isTop) => {
                    const line = candlestickSeries.createPriceLine({
                        price: price,
                        color: '#808080',
                        lineWidth: 1,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        axisLabelVisible: isTop,
                        title: isTop ? `$${(liq.totalLiqValue / 1e6).toFixed(1)}M` : '',
                        axisLabelColor: '#808080',
                        axisLabelTextColor: '#ffffff',
                    });
                    historicalPriceLines.push(line);
                };

                drawLine(liq.kline.high, true);
                drawLine(liq.kline.low, false);
                zonesDrawn++;
            }
        }
        
        function clearAllSeriesData() {
            if (!candlestickSeries) return;
            candlestickSeries.setData([]);
            volumeSeries.setData([]);
            openInterestSeries.setData([]);
            longLiqsSeries.setData([]);
            shortLiqsSeries.setData([]);
            oiVolRatioSeries.setData([]);
            clearAllZones();
        }
        
        function handleResize() { if (chart) chart.resize(chartContainer.clientWidth, chartContainer.clientHeight); }
        
        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeChart();
            applyTheme(currentTheme);
            updateChartData();
            setInterval(() => {
                if (!isUpdating) {
                    updateChartData();
                }
            }, 30000);

            // Drawing Tool Logic
            drawLineTool.addEventListener('click', () => {
                isDrawingMode = !isDrawingMode;
                drawLineTool.classList.toggle('active', isDrawingMode);
            });

            chart.subscribeClick(param => {
                if (!isDrawingMode || !param.point) return;

                const price = candlestickSeries.coordinateToPrice(param.point.y);
                
                const lineToRemove = userDrawnLines.find(line => {
                    const linePrice = line.options().price;
                    const priceRange = chart.priceScale('right').heightToCoordinate(10) - chart.priceScale('right').heightToCoordinate(0);
                    return Math.abs(linePrice - price) < priceRange;
                });

                if (lineToRemove) {
                    candlestickSeries.removePriceLine(lineToRemove);
                    userDrawnLines = userDrawnLines.filter(l => l !== lineToRemove);
                } else {
                    const newLine = candlestickSeries.createPriceLine({
                        price: price,
                        color: '#2962FF',
                        lineWidth: 2,
                        lineStyle: LightweightCharts.LineStyle.Solid,
                        axisLabelVisible: true,
                        title: ''
                    });
                    userDrawnLines.push(newLine);
                }
            });

            themeToggle.addEventListener('click', () => {
                currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
                applyTheme(currentTheme);
            });
            
            symbolSelector.addEventListener('change', (e) => {
                currentSymbol = e.target.value;
                updateChartData();
            });

            intervalButtonsContainer.addEventListener('click', (e) => {
                const target = e.target.closest('.interval-btn');
                if (!target) return;
                intervalButtonsContainer.querySelector('.active').classList.remove('active');
                target.classList.add('active');
                currentInterval = target.dataset.interval;
                updateChartData();
            });
            
            leverageButtonsContainer.addEventListener('click', (e) => {
                const target = e.target.closest('.leverage-btn');
                if (!target) return;
                target.classList.toggle('active');

                selectedLeverages = Array.from(leverageButtonsContainer.querySelectorAll('.active'))
                                    .map(btn => parseInt(btn.dataset.leverage, 10));

                if (selectedLeverages.length === 0) {
                    target.classList.add('active');
                    selectedLeverages.push(parseInt(target.dataset.leverage, 10));
                }
                renderAllVisuals();
            });

            liquiditySlider.addEventListener('input', (e) => {
                liquidityThreshold = parseFloat(e.target.value);
                sliderValueEl.textContent = `$${(liquidityThreshold / 1e6).toFixed(1)}M`;
                renderAllVisuals();
            });

            window.addEventListener('resize', handleResize);
        });
    </script>
</body>
</html>